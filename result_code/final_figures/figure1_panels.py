#!/usr/bin/env python3
"""
Figure 1 Panel Generation Script

This script generates example images for specific panels in Figure 1:
- Panel B: Negative control FOVs (showing low/no background)
- Panel D: FOV overview with spot detection + zoom insets showing spots with different sigma_x
- Panel G: Comparison of spots from green (mHTT1a) and orange (full-length) channels

Output:
    example_images/figure1/
        panel_B_negative_control_*.tif
        panel_D_overview.tif
        panel_D_zoom_sigma_*.tif
        panel_G_green_spots_*.tif
        panel_G_orange_spots_*.tif
"""

import sys
from pathlib import Path
import numpy as np
import pandas as pd
import h5py
from tifffile import imwrite

# Add parent directories for imports
sys.path.insert(0, str(Path(__file__).parent))
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

# Import and apply figure styling
from figure_config import FigureConfig, apply_figure_style
apply_figure_style()

from image_browser import (
    load_fov_metadata, load_fov_level_data, merge_h5_with_fov_data,
    filter_fovs, find_npz_path, find_h5_file, H5_FILE_SEARCH_PATHS
)
from view_npz_stack import load_npz_stack

# Output directory
OUTPUT_DIR = Path(__file__).parent / 'output' / 'example_images' / 'figure1'

# Path to filtered spots CSVs from figure1.py
FILTERED_SPOTS_DIR = Path(__file__).parent / 'output'

# Pixel size for conversions
PIXEL_SIZE_XY = 0.1625  # µm per pixel

# Scale bar sizes (in µm)
SCALE_BAR_OVERVIEW = 50  # 50 µm for full FOV images (~300x300 µm)
SCALE_BAR_ZOOM = 10      # 10 µm for zoom insets (~42x42 µm)


def load_filtered_spots_from_csv(channel: str = 'green'):
    """
    Load filtered spots from CSVs generated by figure1.py.

    NOTE: These CSVs are aggregated by SLIDE, not FOV!
    For per-FOV spots, use load_filtered_spots_for_fov() instead.

    These spots have been filtered using:
    1. PFA filter (pfa_values < MAX_PFA=0.05)
    2. Photon threshold (photons > slide/channel-specific threshold from negative control 95th percentile)

    Returns DataFrame with slide, channel, photons, sigma_x/y/z, pos_x/y/z.
    """
    csv_path = FILTERED_SPOTS_DIR / f'filtered_spots_{channel}.csv'
    if not csv_path.exists():
        print(f"  WARNING: {csv_path} not found. Run figure1.py first to generate filtered spots.")
        return pd.DataFrame()

    df = pd.read_csv(csv_path)
    print(f"  Loaded {len(df):,} filtered {channel} spots from {csv_path.name}")
    return df


def load_photon_thresholds():
    """
    Load photon thresholds from figure1.py output.

    Returns dict mapping (slide, channel) to threshold value.
    """
    csv_path = FILTERED_SPOTS_DIR / 'photon_thresholds.csv'
    if not csv_path.exists():
        print(f"  WARNING: {csv_path} not found. Run figure1.py first.")
        return {}

    df = pd.read_csv(csv_path)
    thresholds = {}
    for _, row in df.iterrows():
        # Parse key like "('m1a1', 'green')" or similar
        key_str = row['key']
        thresholds[key_str] = row['threshold']
    return thresholds


def get_threshold_for_slide_channel(thresholds: dict, slide: str, channel: str):
    """Get the photon threshold for a specific slide and channel."""
    # Try different key formats
    for key, val in thresholds.items():
        if slide in key and channel in key:
            return val
    return None


def load_filtered_spots_for_fov(fov_key: str, slide: str, channel: str = 'green',
                                 h5_path: str = None, thresholds: dict = None):
    """
    Load filtered spots for Panel D using same logic as size_single_spots_beads_v2.py.

    Panel D filtering (matches bead PSF analysis):
    1. PFA filter: spots.pfa_values < MAX_PFA (0.05) - creates a boolean mask
    2. Use this mask to index spots_sigma_var.params_raw to get sigma values
    3. photons > slide/channel-specific threshold (from negative control)

    This gives MORE spots than Panel G (which also applies breakpoint filter).
    Uses spots_sigma_var to have sigma values for colorbar visualization.

    Args:
        fov_key: The FOV identifier in H5 file
        slide: The slide name (e.g., 'm1a1')
        channel: 'green' or 'orange'
        h5_path: Path to H5 file
        thresholds: Dict of photon thresholds from figure1.py

    Returns DataFrame with filtered spots including pos_x, pos_y, pos_z, photons, sigma_x/y/z.
    """
    MAX_PFA = 0.05  # Same as in results_config.py

    if h5_path is None:
        h5_path = find_h5_file()

    if thresholds is None:
        thresholds = load_photon_thresholds()

    # Get threshold for this slide/channel
    threshold_val = get_threshold_for_slide_channel(thresholds, slide, channel)
    if threshold_val is None:
        print(f"  WARNING: No threshold found for {slide}/{channel}")
        return pd.DataFrame()

    with h5py.File(h5_path, 'r') as f:
        if fov_key not in f:
            print(f"  WARNING: FOV {fov_key} not found in H5 file")
            return pd.DataFrame()

        fov_group = f[fov_key]

        try:
            # Get PFA values from spots (same logic as size_single_spots_beads_v2.py)
            spots = fov_group[f'{channel}/spots']
            pfa_values = spots['pfa_values'][:]

            # Create PFA filter: np.any(pfa_values < max_pfa, axis=1)
            # This matches: mask = row["spots.pfa_values"] < max_pfa; row["spots.final_filter"] = np.any(mask, axis=1)
            pfa_filter = np.any(pfa_values < MAX_PFA, axis=1)

            # Use spots_sigma_var to get sigma values (has 8 columns in params_raw)
            sigma_var = fov_group[f'{channel}/spots_sigma_var']

            # params_raw columns: x, y, z, photons, bg, sigma_x, sigma_y, sigma_z
            params_raw = sigma_var['params_raw'][:]
            filtered_coords = sigma_var['filtered_coords'][:]
            z_starts = sigma_var['z_starts'][:]

            # Apply PFA filter to index spots_sigma_var data
            # (same as: photon_arr_sig = row["spots_sigma_var.params_raw"][row["spots.final_filter"], 3])
            photons = params_raw[pfa_filter, 3]
            coords = filtered_coords[pfa_filter]
            z = z_starts[pfa_filter]
            sigma_x = params_raw[pfa_filter, 5]
            sigma_y = params_raw[pfa_filter, 6]
            sigma_z = params_raw[pfa_filter, 7]

            # Apply photon threshold
            photon_mask = photons > threshold_val

            # Create DataFrame with only spots passing both filters
            spots_df = pd.DataFrame({
                'pos_x': coords[photon_mask, 1],  # col = x
                'pos_y': coords[photon_mask, 0],  # row = y
                'pos_z': z[photon_mask],
                'photons': photons[photon_mask],
                'sigma_x': sigma_x[photon_mask],
                'sigma_y': sigma_y[photon_mask],
                'sigma_z': sigma_z[photon_mask],
            })

            return spots_df

        except KeyError as e:
            print(f"  WARNING: Missing data for {channel} in {fov_key}: {e}")
            return pd.DataFrame()


def load_spots_for_fov(fov_key: str, channel: str = 'green', h5_path: str = None,
                       use_sigma_var: bool = False):
    """
    Load individual spot data for a specific FOV and channel.

    Uses the same filtering as figure1.py: spots.final_filter when USE_FINAL_FILTER=True
    (which is the default in results_config.py).

    Args:
        fov_key: The FOV identifier
        channel: 'green' or 'orange'
        h5_path: Path to H5 file (will auto-find if None)
        use_sigma_var: If True, use spots_sigma_var (has sigma values but fewer spots)
                       If False, use spots (more spots, uses final_filter)

    Returns DataFrame with pos_x, pos_y, pos_z (pixel positions in the image).
    Uses filtered_coords directly as the position (initial center estimate).
    """
    if h5_path is None:
        h5_path = find_h5_file()

    with h5py.File(h5_path, 'r') as f:
        fov_group = f[fov_key]

        if use_sigma_var:
            # Use spots_sigma_var - has sigma values but stricter filter
            base_path = f'{channel}/spots_sigma_var'
            try:
                params_raw = fov_group[f'{base_path}/params_raw'][:]
                final_filter = fov_group[f'{base_path}/final_filter'][:]
                filtered_coords = fov_group[f'{base_path}/filtered_coords'][:]
                z_starts = fov_group[f'{base_path}/z_starts'][:]

                # Use filtered_coords directly as position
                # filtered_coords is (row, col) = (y, x)
                # params_raw columns: x, y, z, photons, bg, sigma_x, sigma_y, sigma_z
                spots_df = pd.DataFrame({
                    'pos_x': filtered_coords[:, 1],  # col = x
                    'pos_y': filtered_coords[:, 0],  # row = y
                    'pos_z': z_starts,
                    'photons': params_raw[:, 3],
                    'background': params_raw[:, 4],
                    'sigma_x': params_raw[:, 5],
                    'sigma_y': params_raw[:, 6],
                    'sigma_z': params_raw[:, 7],
                    'pass_filter': final_filter
                })
                return spots_df

            except KeyError:
                print(f"  WARNING: No spots_sigma_var data for {channel} in {fov_key}")
                return pd.DataFrame()

        else:
            # Use regular spots with filter_indices (main spot detection output)
            # This gives us all detected spots that passed the initial PFA filter
            base_path = f'{channel}/spots'
            try:
                # filter_indices is the boolean mask for spots that passed detection
                filter_indices = fov_group[f'{base_path}/filter_indices'][:]
                filtered_coords = fov_group[f'{base_path}/filtered_coords'][:]
                z_starts = fov_group[f'{base_path}/z_starts'][:]
                params_raw = fov_group[f'{base_path}/params_raw'][:]

                # Use filtered_coords directly as position
                # params_raw columns: x, y, z, photons, bg
                spots_df = pd.DataFrame({
                    'pos_x': filtered_coords[:, 1],  # col = x
                    'pos_y': filtered_coords[:, 0],  # row = y
                    'pos_z': z_starts,
                    'photons': params_raw[:, 3],
                    'background': params_raw[:, 4],
                    'pass_filter': filter_indices
                })

                # Try to get dist_to_dapi_um (indexed to filter_indices passing spots)
                try:
                    dist = fov_group[f'{base_path}/dist_to_dapi_um'][:]
                    # dist_to_dapi_um is for spots where filter_indices=True
                    if len(dist) == filter_indices.sum():
                        dist_full = np.full(len(filter_indices), np.nan)
                        dist_full[filter_indices] = dist
                        spots_df['dist_to_dapi_um'] = dist_full
                except KeyError:
                    pass

                return spots_df

            except KeyError as e:
                print(f"  WARNING: No spot data for {channel} in {fov_key}: {e}")
                return pd.DataFrame()


def load_all_spots_with_threshold(fov_key: str, slide: str, channel: str = 'green',
                                    h5_path: str = None, thresholds: dict = None):
    """
    Load ALL spots for a FOV with classification by photon threshold.

    Uses spots (not spots_sigma_var) with filter_indices.
    Returns both spots that pass and fail the photon threshold.

    Args:
        fov_key: The FOV identifier
        slide: Slide name for threshold lookup
        channel: 'green' or 'orange'
        h5_path: Path to H5 file
        thresholds: Dict of photon thresholds

    Returns:
        Tuple of (spots_passed, spots_failed) DataFrames
    """
    if h5_path is None:
        h5_path = find_h5_file()

    if thresholds is None:
        thresholds = load_photon_thresholds()

    # Get threshold for this slide/channel
    threshold_val = get_threshold_for_slide_channel(thresholds, slide, channel)

    with h5py.File(h5_path, 'r') as f:
        if fov_key not in f:
            return pd.DataFrame(), pd.DataFrame()

        fov_group = f[fov_key]
        base_path = f'{channel}/spots'

        try:
            filter_indices = fov_group[f'{base_path}/filter_indices'][:]
            filtered_coords = fov_group[f'{base_path}/filtered_coords'][:]
            z_starts = fov_group[f'{base_path}/z_starts'][:]
            params_raw = fov_group[f'{base_path}/params_raw'][:]

            # Get spots that passed filter_indices
            passed_filter = filter_indices

            spots_df = pd.DataFrame({
                'pos_x': filtered_coords[passed_filter, 1],
                'pos_y': filtered_coords[passed_filter, 0],
                'pos_z': z_starts[passed_filter],
                'photons': params_raw[passed_filter, 3],
            })

            if threshold_val is not None and len(spots_df) > 0:
                # Split by photon threshold
                passed_threshold = spots_df['photons'] > threshold_val
                spots_passed = spots_df[passed_threshold].copy()
                spots_failed = spots_df[~passed_threshold].copy()
                return spots_passed, spots_failed
            else:
                return spots_df, pd.DataFrame()

        except KeyError as e:
            print(f"  WARNING: No spot data for {channel} in {fov_key}: {e}")
            return pd.DataFrame(), pd.DataFrame()


def load_spots_with_sigma(fov_key: str, channel: str = 'green', h5_path: str = None):
    """
    Load spots that have sigma values from spots_sigma_var.
    Returns spots with pixel positions and sigma values.

    Uses filter_indices from spots_sigma_var to get spots that passed sigma fitting.
    The photons/sigma arrays are already filtered to these spots.

    NOTE: This does NOT apply the photon threshold. Use load_filtered_spots_with_sigma
    for filtering consistent with figure1.py.
    """
    if h5_path is None:
        h5_path = find_h5_file()

    with h5py.File(h5_path, 'r') as f:
        fov_group = f[fov_key]
        base_path = f'{channel}/spots_sigma_var'

        try:
            # params_raw has ALL candidates (N_total, 8)
            # columns: x, y, z, photons, bg, sigma_x, sigma_y, sigma_z
            params_raw = fov_group[f'{base_path}/params_raw'][:]

            # filter_indices tells us which candidates passed
            filter_indices = fov_group[f'{base_path}/filter_indices'][:]  # Boolean mask

            # filtered_coords and z_starts are for ALL candidates
            filtered_coords = fov_group[f'{base_path}/filtered_coords'][:]
            z_starts = fov_group[f'{base_path}/z_starts'][:]

            if filter_indices.sum() == 0:
                print(f"  WARNING: No sigma_var spots pass filter for {channel} in {fov_key}")
                return pd.DataFrame()

            # Get only the spots that passed the filter
            fc = filtered_coords[filter_indices]
            zs = z_starts[filter_indices]
            params_filtered = params_raw[filter_indices]

            spots_df = pd.DataFrame({
                'pos_x': fc[:, 1],  # col = x
                'pos_y': fc[:, 0],  # row = y
                'pos_z': zs,
                'photons': params_filtered[:, 3],
                'sigma_x': params_filtered[:, 5],
                'sigma_y': params_filtered[:, 6],
                'sigma_z': params_filtered[:, 7],
            })

            return spots_df

        except KeyError as e:
            print(f"  WARNING: No sigma_var data for {channel} in {fov_key}: {e}")
            return pd.DataFrame()


def load_filtered_spots_with_sigma(fov_key: str, slide: str, channel: str = 'green',
                                    h5_path: str = None, thresholds: dict = None):
    """
    Load filtered spots with sigma values - uses STRICTER filtering than Panel D.

    Panel G filtering (from size_single_spots_normalized.py):
    1. spots_sigma_var.filter_indices (spots that passed sigma fitting)
    2. spots_sigma_var.filter_on_break (breakpoint filter for single-molecule spots)
    3. photons > slide/channel-specific threshold (from negative control)

    This is DIFFERENT from Panel D which uses spots.filter_indices (more spots).
    Panel G uses variable sigma estimates and breakpoint filtering for cleaner
    single-molecule detection.

    Args:
        fov_key: The FOV identifier in H5 file
        slide: The slide name (e.g., 'm1a1')
        channel: 'green' or 'orange'
        h5_path: Path to H5 file
        thresholds: Dict of photon thresholds from figure1.py

    Returns DataFrame with filtered spots including pos_x, pos_y, pos_z, photons, sigma_x/y/z.
    """
    if h5_path is None:
        h5_path = find_h5_file()

    if thresholds is None:
        thresholds = load_photon_thresholds()

    # Get threshold for this slide/channel
    threshold_val = get_threshold_for_slide_channel(thresholds, slide, channel)
    if threshold_val is None:
        print(f"  WARNING: No threshold found for {slide}/{channel}")
        return pd.DataFrame()

    with h5py.File(h5_path, 'r') as f:
        if fov_key not in f:
            print(f"  WARNING: FOV {fov_key} not found in H5 file")
            return pd.DataFrame()

        fov_group = f[fov_key]

        try:
            # Load from spots_sigma_var (has sigma values from variable PSF fitting)
            sigma_var = fov_group[f'{channel}/spots_sigma_var']

            # params_raw columns: x, y, z, photons, bg, sigma_x, sigma_y, sigma_z
            params_raw = sigma_var['params_raw'][:]
            filtered_coords = sigma_var['filtered_coords'][:]
            z_starts = sigma_var['z_starts'][:]

            # Get BOTH filters
            filter_indices = sigma_var['filter_indices'][:]  # Sigma fitting passed
            filter_on_break = sigma_var['filter_on_break'][:]  # Breakpoint filter

            # Combined filter: must pass BOTH sigma fitting AND breakpoint filter
            combined_filter = filter_indices & filter_on_break

            if combined_filter.sum() == 0:
                print(f"  WARNING: No spots pass combined filter for {channel} in {fov_key}")
                return pd.DataFrame()

            # Apply combined filter
            photons = params_raw[combined_filter, 3]
            coords = filtered_coords[combined_filter]
            z = z_starts[combined_filter]
            sigma_x = params_raw[combined_filter, 5]
            sigma_y = params_raw[combined_filter, 6]
            sigma_z = params_raw[combined_filter, 7]

            # Apply photon threshold
            photon_mask = photons > threshold_val

            # Create DataFrame with only spots passing all filters
            spots_df = pd.DataFrame({
                'pos_x': coords[photon_mask, 1],  # col = x
                'pos_y': coords[photon_mask, 0],  # row = y
                'pos_z': z[photon_mask],
                'photons': photons[photon_mask],
                'sigma_x': sigma_x[photon_mask],
                'sigma_y': sigma_y[photon_mask],
                'sigma_z': sigma_z[photon_mask],
            })

            return spots_df

        except KeyError as e:
            print(f"  WARNING: Missing sigma_var data for {channel} in {fov_key}: {e}")
            return pd.DataFrame()


def load_and_project_npz(npz_path: str) -> dict:
    """Load NPZ file and create max projections for each channel."""
    arr, metadata = load_npz_stack(npz_path)

    channels = metadata.get('channels', ['mDAPI', 'sFITC', 'sCY3', 'sCY5'])
    channel_map = {
        'mDAPI': 'blue',
        'sFITC': 'green',
        'sCY3': 'orange',
        'sCY5': 'red'
    }

    projections = {}
    stacks = {}  # Keep 3D stacks for zoom extraction
    for i, ch_name in enumerate(channels):
        color_key = channel_map.get(ch_name, ch_name.lower())
        stack = arr[i]  # Shape: (z, y, x)
        stacks[color_key] = stack
        projections[color_key] = np.max(stack, axis=0)  # Max projection

    return projections, stacks


def normalize_image(img, percentile_low=1, percentile_high=99.5):
    """Normalize image to 0-1 range using percentiles."""
    vmin, vmax = np.percentile(img, [percentile_low, percentile_high])
    img_norm = np.clip((img - vmin) / (vmax - vmin + 1e-10), 0, 1)
    return img_norm


def add_scale_bar(img, scale_bar_um=10, pixel_size_um=PIXEL_SIZE_XY,
                  position='bottom_right', color=(255, 255, 255),
                  bar_height=5, padding=10, add_text=True):
    """
    Add a scale bar to an image with optional text label.

    Args:
        img: RGB image (H, W, 3) uint8
        scale_bar_um: Length of scale bar in micrometers
        pixel_size_um: Pixel size in micrometers
        position: 'bottom_right', 'bottom_left', 'top_right', 'top_left'
        color: RGB tuple for scale bar color
        bar_height: Height of scale bar in pixels
        padding: Padding from edge in pixels
        add_text: If True, add text label showing scale bar size

    Returns:
        Modified image with scale bar
    """
    from PIL import Image, ImageDraw, ImageFont

    img = img.copy()
    h, w = img.shape[:2]

    # Calculate scale bar length in pixels
    bar_length_px = int(scale_bar_um / pixel_size_um)

    # Determine position
    if 'bottom' in position:
        y_start = h - padding - bar_height
    else:
        y_start = padding

    if 'right' in position:
        x_start = w - padding - bar_length_px
    else:
        x_start = padding

    y_end = y_start + bar_height
    x_end = x_start + bar_length_px

    # Draw scale bar
    img[y_start:y_end, x_start:x_end] = color

    # Add text label if requested
    if add_text:
        # Convert to PIL Image for text rendering
        pil_img = Image.fromarray(img)
        draw = ImageDraw.Draw(pil_img)

        # Create text label
        text = f"{scale_bar_um} µm"

        # Try to use a reasonable font size based on image size
        font_size = max(12, min(24, h // 50))
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", font_size)
        except (IOError, OSError):
            try:
                font = ImageFont.truetype("/usr/share/fonts/TTF/DejaVuSans.ttf", font_size)
            except (IOError, OSError):
                font = ImageFont.load_default()

        # Get text bounding box
        bbox = draw.textbbox((0, 0), text, font=font)
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]

        # Position text centered above the scale bar
        text_x = x_start + (bar_length_px - text_width) // 2
        text_y = y_start - text_height - 4

        # Draw text with black outline for visibility
        outline_color = (0, 0, 0)
        for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1), (-1, 0), (1, 0), (0, -1), (0, 1)]:
            draw.text((text_x + dx, text_y + dy), text, font=font, fill=outline_color)
        draw.text((text_x, text_y), text, font=font, fill=color)

        # Convert back to numpy array
        img = np.array(pil_img)

    return img


def add_zoom_box(img, center_x, center_y, box_size, color=(255, 255, 0), thickness=2):
    """
    Add a box outline showing the zoom region location.

    Args:
        img: RGB image (H, W, 3) uint8
        center_x, center_y: Center of the zoom region
        box_size: Size of the zoom box
        color: RGB tuple for box color (default yellow)
        thickness: Line thickness in pixels

    Returns:
        Modified image with zoom box
    """
    img = img.copy()
    h, w = img.shape[:2]

    # Calculate box coordinates
    half = box_size // 2
    x_min = max(0, center_x - half)
    x_max = min(w, center_x + half)
    y_min = max(0, center_y - half)
    y_max = min(h, center_y + half)

    # Draw box outline (top, bottom, left, right edges)
    for t in range(thickness):
        # Top edge
        if y_min + t < h:
            img[y_min + t, x_min:x_max] = color
        # Bottom edge
        if y_max - 1 - t >= 0:
            img[y_max - 1 - t, x_min:x_max] = color
        # Left edge
        if x_min + t < w:
            img[y_min:y_max, x_min + t] = color
        # Right edge
        if x_max - 1 - t >= 0:
            img[y_min:y_max, x_max - 1 - t] = color

    return img


def add_dynamic_range_text(img, dynamic_range, position='top_left', padding=10):
    """
    Add a dynamic range text box to an image.

    Args:
        img: RGB image (H, W, 3) uint8
        dynamic_range: Tuple (min, max) showing the intensity range
        position: 'top_left', 'top_right', 'bottom_left', 'bottom_right'
        padding: Padding from edge in pixels

    Returns:
        Modified image with dynamic range text
    """
    from PIL import Image, ImageDraw, ImageFont

    img = img.copy()
    h, w = img.shape[:2]

    # Convert to PIL Image for text rendering
    pil_img = Image.fromarray(img)
    draw = ImageDraw.Draw(pil_img)

    # Create text label
    text = f"Range: {dynamic_range[0]:.0f}-{dynamic_range[1]:.0f}"

    # Try to use a reasonable font size based on image size
    font_size = max(12, min(24, h // 50))
    try:
        font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", font_size)
    except (IOError, OSError):
        try:
            font = ImageFont.truetype("/usr/share/fonts/TTF/DejaVuSans.ttf", font_size)
        except (IOError, OSError):
            font = ImageFont.load_default()

    # Get text bounding box
    bbox = draw.textbbox((0, 0), text, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]

    # Determine position
    if 'left' in position:
        text_x = padding
    else:
        text_x = w - padding - text_width

    if 'top' in position:
        text_y = padding
    else:
        text_y = h - padding - text_height

    # Draw background box
    box_padding = 4
    box_coords = [
        text_x - box_padding,
        text_y - box_padding,
        text_x + text_width + box_padding,
        text_y + text_height + box_padding
    ]
    draw.rectangle(box_coords, fill=(0, 0, 0, 180))

    # Draw text in white
    draw.text((text_x, text_y), text, font=font, fill=(255, 255, 255))

    # Convert back to numpy array
    img = np.array(pil_img)

    return img


def get_scale_bar_info(img_shape, scale_bar_um=10, pixel_size_um=PIXEL_SIZE_XY):
    """
    Get scale bar information for metadata.

    Returns dict with scale bar details.
    """
    h, w = img_shape[:2]
    bar_length_px = int(scale_bar_um / pixel_size_um)
    img_width_um = w * pixel_size_um
    img_height_um = h * pixel_size_um

    return {
        'scale_bar_um': scale_bar_um,
        'scale_bar_px': bar_length_px,
        'image_width_px': w,
        'image_height_px': h,
        'image_width_um': img_width_um,
        'image_height_um': img_height_um,
        'pixel_size_um': pixel_size_um
    }


def save_grayscale_tiff(img, output_path, bits=16):
    """Save normalized image as grayscale TIFF."""
    img_norm = normalize_image(img)
    if bits == 16:
        img_out = (img_norm * 65535).astype(np.uint16)
    else:
        img_out = (img_norm * 255).astype(np.uint8)
    imwrite(str(output_path), img_out)


def save_colored_tiff(img, output_path, channel='blue', img_range=None,
                       scale_bar_um=None, dynamic_range=None):
    """
    Save image as color-coded RGB TIFF.

    Args:
        img: 2D array
        output_path: Where to save
        channel: 'blue' (DAPI), 'green' (mHTT1a), or 'orange' (full-length)
        img_range: Optional (vmin, vmax) tuple for normalization
        scale_bar_um: Optional scale bar length in micrometers (None = no scale bar)
        dynamic_range: Optional (min, max) tuple to display as text (None = no text)
    """
    if img_range is not None:
        vmin, vmax = img_range
        img_norm = np.clip((img - vmin) / (vmax - vmin + 1e-10), 0, 1)
    else:
        img_norm = normalize_image(img)

    # Create RGB image with appropriate color
    shape = img.shape
    rgb = np.zeros((*shape, 3), dtype=np.uint8)

    if channel == 'blue':
        # Blue channel only
        rgb[:, :, 2] = (img_norm * 255).astype(np.uint8)
    elif channel == 'green':
        # Green channel only
        rgb[:, :, 1] = (img_norm * 255).astype(np.uint8)
    elif channel == 'orange':
        # Orange: RGB(255, 165, 0)
        rgb[:, :, 0] = (img_norm * 255).astype(np.uint8)
        rgb[:, :, 1] = (img_norm * 165).astype(np.uint8)

    # Add scale bar if requested
    if scale_bar_um is not None:
        rgb = add_scale_bar(rgb, scale_bar_um=scale_bar_um)

    # Add dynamic range text if requested
    if dynamic_range is not None:
        rgb = add_dynamic_range_text(rgb, dynamic_range)

    imwrite(str(output_path), rgb)


def save_rgb_tiff(blue_img, green_img, orange_img, output_path,
                  blue_range=None, green_range=None, orange_range=None,
                  scale_bar_um=None, dynamic_range=None):
    """
    Save merged RGB TIFF (Blue=DAPI, Green=mHTT1a, Orange=full-length).

    Orange is rendered as RGB(255, 165, 0) - actual orange color, not red.
    Uses screen blending to avoid saturation when channels overlap.

    Args:
        blue_img, green_img, orange_img: 2D arrays for each channel
        output_path: Where to save the merged image
        blue_range, green_range, orange_range: Optional (vmin, vmax) tuples for
            consistent normalization across images. If None, auto-normalize.
        scale_bar_um: Optional scale bar length in micrometers
        dynamic_range: Optional (min, max) tuple to display as text
    """
    rgb = create_merged_rgb(blue_img, green_img, orange_img,
                            blue_range, green_range, orange_range)
    if scale_bar_um is not None:
        rgb = add_scale_bar(rgb, scale_bar_um=scale_bar_um)
    if dynamic_range is not None:
        rgb = add_dynamic_range_text(rgb, dynamic_range)
    imwrite(str(output_path), rgb)


def save_image_as_svg(rgb_or_gray, output_path, dynamic_range=None,
                       scale_bar_um=None, channel=None, img_range=None):
    """
    Save an image as SVG with scale bar and dynamic range text box.

    Args:
        rgb_or_gray: RGB array (H, W, 3) or grayscale array (H, W)
        output_path: Where to save (will be saved as .svg)
        dynamic_range: Tuple (min, max) for the dynamic range text box.
                       If None, computed from input image.
        scale_bar_um: Scale bar length in micrometers (default: SCALE_BAR_OVERVIEW)
        channel: If grayscale input, colorize as 'blue', 'green', 'orange', or None (grayscale)
        img_range: Optional (vmin, vmax) for normalization of grayscale input
    """
    import matplotlib.pyplot as plt
    from matplotlib.patches import Rectangle

    # Handle grayscale input
    if rgb_or_gray.ndim == 2:
        # Normalize
        if img_range is not None:
            vmin, vmax = img_range
            img_norm = np.clip((rgb_or_gray - vmin) / (vmax - vmin + 1e-10), 0, 1)
        else:
            img_norm = normalize_image(rgb_or_gray)

        # Compute dynamic range before normalization if not provided
        if dynamic_range is None:
            dynamic_range = (rgb_or_gray.min(), rgb_or_gray.max())

        # Colorize
        shape = rgb_or_gray.shape
        rgb = np.zeros((*shape, 3), dtype=np.uint8)
        if channel == 'blue':
            rgb[:, :, 2] = (img_norm * 255).astype(np.uint8)
        elif channel == 'green':
            rgb[:, :, 1] = (img_norm * 255).astype(np.uint8)
        elif channel == 'orange':
            rgb[:, :, 0] = (img_norm * 255).astype(np.uint8)
            rgb[:, :, 1] = (img_norm * 165).astype(np.uint8)
        else:
            # Grayscale
            rgb[:, :, 0] = (img_norm * 255).astype(np.uint8)
            rgb[:, :, 1] = (img_norm * 255).astype(np.uint8)
            rgb[:, :, 2] = (img_norm * 255).astype(np.uint8)
    else:
        rgb = rgb_or_gray
        if dynamic_range is None:
            # Estimate from RGB (use max channel)
            dynamic_range = (rgb.min(), rgb.max())

    # Default scale bar
    if scale_bar_um is None:
        scale_bar_um = SCALE_BAR_OVERVIEW

    # Create figure
    cfg = FigureConfig
    fig_width = 4.0  # inches
    aspect = rgb.shape[0] / rgb.shape[1]
    fig, ax = plt.subplots(figsize=(fig_width, fig_width * aspect))
    ax.imshow(rgb)
    ax.axis('off')

    # Add scale bar
    scale_bar_px = int(scale_bar_um / PIXEL_SIZE_XY)
    img_h, img_w = rgb.shape[:2]
    bar_height = max(5, int(img_h * 0.015))  # Scale bar height proportional to image
    padding = max(10, int(img_w * 0.02))

    bar_x = img_w - padding - scale_bar_px
    bar_y = img_h - padding - bar_height
    scale_bar_rect = Rectangle((bar_x, bar_y), scale_bar_px, bar_height,
                                 facecolor='white', edgecolor='none')
    ax.add_patch(scale_bar_rect)
    ax.text(bar_x + scale_bar_px/2, bar_y - 3, f'{scale_bar_um} µm',
           color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK,
           ha='center', va='bottom')

    # Add dynamic range text box
    dr_text = f'Range: {dynamic_range[0]:.0f}-{dynamic_range[1]:.0f}'
    ax.text(padding, padding, dr_text, color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK,
           ha='left', va='top',
           bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7))

    plt.tight_layout(pad=0.1)

    # Save as SVG
    svg_path = str(output_path)
    if not svg_path.endswith('.svg'):
        svg_path = svg_path.replace('.tif', '.svg').replace('.png', '.svg')
        if not svg_path.endswith('.svg'):
            svg_path = svg_path + '.svg'
    plt.savefig(svg_path, format='svg', bbox_inches='tight')
    plt.close()

    return svg_path


def save_composite_svg(rgb, output_path, green_range=None, orange_range=None,
                       blue_range=None, scale_bar_um=None, zoom_boxes=None,
                       zoom_box_color='yellow', zoom_box_linewidth=2):
    """
    Save a composite RGB image as SVG with per-channel dynamic range annotations.

    Args:
        rgb: RGB array (H, W, 3)
        output_path: Where to save (will be saved as .svg)
        green_range: Tuple (min, max) for green channel dynamic range
        orange_range: Tuple (min, max) for orange channel dynamic range
        blue_range: Tuple (min, max) for blue channel dynamic range (optional, not shown by default)
        scale_bar_um: Scale bar length in micrometers (default: SCALE_BAR_OVERVIEW)
        zoom_boxes: List of (center_x, center_y, box_size) tuples for zoom box rectangles
                    These are drawn as vector elements (adjustable in SVG editors)
        zoom_box_color: Color for zoom boxes (default: 'yellow')
        zoom_box_linewidth: Line width for zoom boxes (default: 2)
    """
    import matplotlib.pyplot as plt
    from matplotlib.patches import Rectangle

    if scale_bar_um is None:
        scale_bar_um = SCALE_BAR_OVERVIEW

    # Create figure
    cfg = FigureConfig
    fig_width = 4.0  # inches
    aspect = rgb.shape[0] / rgb.shape[1]
    fig, ax = plt.subplots(figsize=(fig_width, fig_width * aspect))
    ax.imshow(rgb)
    ax.axis('off')

    # Add zoom boxes as vector rectangles (adjustable in SVG)
    if zoom_boxes is not None:
        img_h, img_w = rgb.shape[:2]
        for box in zoom_boxes:
            if len(box) == 3:
                cx, cy, box_size = box
            else:
                # Support (name, cx, cy) format from zoom_locations
                _, cx, cy = box[:3]
                box_size = zoom_boxes[0][2] if len(zoom_boxes[0]) == 3 else 256  # default

            half = box_size // 2
            x_min = max(0, cx - half)
            y_min = max(0, cy - half)
            # Clamp to image bounds
            x_max = min(img_w, cx + half)
            y_max = min(img_h, cy + half)
            width = x_max - x_min
            height = y_max - y_min

            zoom_rect = Rectangle((x_min, y_min), width, height,
                                   facecolor='none', edgecolor=zoom_box_color,
                                   linewidth=zoom_box_linewidth)
            ax.add_patch(zoom_rect)

    # Add scale bar
    scale_bar_px = int(scale_bar_um / PIXEL_SIZE_XY)
    img_h, img_w = rgb.shape[:2]
    bar_height = max(5, int(img_h * 0.015))
    padding = max(10, int(img_w * 0.02))

    bar_x = img_w - padding - scale_bar_px
    bar_y = img_h - padding - bar_height
    scale_bar_rect = Rectangle((bar_x, bar_y), scale_bar_px, bar_height,
                                 facecolor='white', edgecolor='none')
    ax.add_patch(scale_bar_rect)
    ax.text(bar_x + scale_bar_px/2, bar_y - 3, f'{scale_bar_um} µm',
           color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK,
           ha='center', va='bottom')

    # Add per-channel dynamic range text boxes
    y_offset = padding
    line_height = 18  # Approximate line height in pixels

    if green_range is not None:
        dr_text_green = f'Green: {green_range[0]:.0f}-{green_range[1]:.0f}'
        ax.text(padding, y_offset, dr_text_green, color='lime', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.7))
        y_offset += line_height

    if orange_range is not None:
        dr_text_orange = f'Orange: {orange_range[0]:.0f}-{orange_range[1]:.0f}'
        ax.text(padding, y_offset, dr_text_orange, color='orange', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.7))
        y_offset += line_height

    if blue_range is not None:
        dr_text_blue = f'Blue: {blue_range[0]:.0f}-{blue_range[1]:.0f}'
        ax.text(padding, y_offset, dr_text_blue, color='cyan', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.7))

    plt.tight_layout(pad=0.1)

    # Save as SVG
    svg_path = str(output_path)
    if not svg_path.endswith('.svg'):
        svg_path = svg_path.replace('.tif', '.svg').replace('.png', '.svg')
        if not svg_path.endswith('.svg'):
            svg_path = svg_path + '.svg'
    plt.savefig(svg_path, format='svg', bbox_inches='tight')
    plt.close()

    return svg_path


def create_merged_rgb(blue_img, green_img, orange_img,
                      blue_range=None, green_range=None, orange_range=None):
    """
    Create merged RGB array (Blue=DAPI, Green=mHTT1a, Orange=full-length).

    Orange is rendered as RGB(255, 165, 0) - actual orange color, not red.
    Uses screen blending to avoid saturation when channels overlap.

    Args:
        blue_img, green_img, orange_img: 2D arrays for each channel
        blue_range, green_range, orange_range: Optional (vmin, vmax) tuples for
            consistent normalization across images. If None, auto-normalize.

    Returns:
        RGB uint8 array
    """
    shape = blue_img.shape
    # Use float for blending to avoid saturation
    rgb = np.zeros((*shape, 3), dtype=np.float32)

    # Normalize each channel
    if blue_img is not None:
        if blue_range is not None:
            vmin, vmax = blue_range
            blue_norm = np.clip((blue_img - vmin) / (vmax - vmin + 1e-10), 0, 1)
        else:
            blue_norm = normalize_image(blue_img)
    else:
        blue_norm = np.zeros(shape)

    if green_img is not None:
        if green_range is not None:
            vmin, vmax = green_range
            green_norm = np.clip((green_img - vmin) / (vmax - vmin + 1e-10), 0, 1)
        else:
            green_norm = normalize_image(green_img)
    else:
        green_norm = np.zeros(shape)

    if orange_img is not None:
        if orange_range is not None:
            vmin, vmax = orange_range
            orange_norm = np.clip((orange_img - vmin) / (vmax - vmin + 1e-10), 0, 1)
        else:
            orange_norm = normalize_image(orange_img)
    else:
        orange_norm = np.zeros(shape)

    # Build RGB using screen blending formula: 1 - (1-a)*(1-b)
    # This prevents saturation while preserving color information

    # Red channel: only orange contributes
    rgb[:, :, 0] = orange_norm

    # Green channel: green (mHTT1a) + orange contribution (165/255 = 0.647)
    # Use screen blending: 1 - (1-green)*(1-orange*0.647)
    orange_g_contrib = orange_norm * (165.0 / 255.0)
    rgb[:, :, 1] = 1.0 - (1.0 - green_norm) * (1.0 - orange_g_contrib)

    # Blue channel: only DAPI contributes
    rgb[:, :, 2] = blue_norm

    # Convert to uint8
    rgb = np.clip(rgb * 255, 0, 255).astype(np.uint8)

    return rgb


def draw_spot_circles(img, spots_df, radius=3, color=(255, 255, 0), thickness=1):
    """
    Draw circles at spot locations on an image.

    Args:
        img: RGB image as numpy array (H, W, 3) uint8
        spots_df: DataFrame with 'pos_x' and 'pos_y' columns
        radius: Circle radius in pixels
        color: RGB tuple for circle color (default yellow)
        thickness: Line thickness (1 or 2 typically)

    Returns:
        Image with circles drawn
    """
    from skimage.draw import disk, circle_perimeter

    # Make a copy to avoid modifying original
    img_out = img.copy()

    for _, spot in spots_df.iterrows():
        x = int(round(spot['pos_x']))
        y = int(round(spot['pos_y']))

        # Check bounds
        if 0 <= x < img.shape[1] and 0 <= y < img.shape[0]:
            # Draw circle perimeter (outline)
            rr, cc = circle_perimeter(y, x, radius, shape=img.shape[:2])
            img_out[rr, cc] = color

    return img_out


def save_image_with_spots(img, spots_df, output_path, circle_radius=3,
                          circle_color=(255, 255, 0), thickness=1):
    """
    Save a grayscale image with spot circles overlaid.

    Args:
        img: 2D grayscale image
        spots_df: DataFrame with 'pos_x' and 'pos_y' columns
        output_path: Path to save the output
        circle_radius: Radius of circles in pixels
        circle_color: RGB tuple for circle color
        thickness: Line thickness
    """
    # Normalize and convert to RGB
    img_norm = normalize_image(img)
    img_8bit = (img_norm * 255).astype(np.uint8)

    # Convert grayscale to RGB
    rgb = np.stack([img_8bit, img_8bit, img_8bit], axis=-1)

    # Draw circles
    rgb_with_spots = draw_spot_circles(rgb, spots_df, radius=circle_radius,
                                        color=circle_color, thickness=thickness)

    imwrite(str(output_path), rgb_with_spots)


def save_image_with_spots_colored(img, spots_df, output_path, channel='green',
                                   circle_radius=3, circle_color=(255, 255, 0),
                                   scale_bar_um=None):
    """
    Save a color-coded image with spot circles overlaid.

    Args:
        img: 2D grayscale image
        spots_df: DataFrame with 'pos_x' and 'pos_y' columns
        output_path: Path to save the output
        channel: 'blue', 'green', or 'orange' for color coding
        circle_radius: Radius of circles in pixels
        circle_color: RGB tuple for circle color
        scale_bar_um: Optional scale bar length in micrometers
    """
    # Normalize image
    img_norm = normalize_image(img)

    # Create color-coded RGB image
    shape = img.shape
    rgb = np.zeros((*shape, 3), dtype=np.uint8)

    if channel == 'blue':
        rgb[:, :, 2] = (img_norm * 255).astype(np.uint8)
    elif channel == 'green':
        rgb[:, :, 1] = (img_norm * 255).astype(np.uint8)
    elif channel == 'orange':
        rgb[:, :, 0] = (img_norm * 255).astype(np.uint8)
        rgb[:, :, 1] = (img_norm * 165).astype(np.uint8)

    # Draw circles
    rgb_with_spots = draw_spot_circles(rgb, spots_df, radius=circle_radius,
                                        color=circle_color, thickness=1)

    # Add scale bar if requested
    if scale_bar_um is not None:
        rgb_with_spots = add_scale_bar(rgb_with_spots, scale_bar_um=scale_bar_um)

    imwrite(str(output_path), rgb_with_spots)


def save_rgb_with_spots(blue_img, green_img, orange_img, spots_df, output_path,
                        circle_radius=3, circle_color=(255, 255, 0), thickness=1):
    """
    Save merged RGB TIFF with spot circles overlaid.
    """
    shape = blue_img.shape
    rgb = np.zeros((*shape, 3), dtype=np.uint8)

    if blue_img is not None:
        rgb[:, :, 2] = (normalize_image(blue_img) * 255).astype(np.uint8)
    if green_img is not None:
        rgb[:, :, 1] = (normalize_image(green_img) * 255).astype(np.uint8)
    if orange_img is not None:
        rgb[:, :, 0] = (normalize_image(orange_img) * 255).astype(np.uint8)

    # Draw circles
    rgb_with_spots = draw_spot_circles(rgb, spots_df, radius=circle_radius,
                                        color=circle_color, thickness=thickness)

    imwrite(str(output_path), rgb_with_spots)


def save_image_svg_with_vector_circles(rgb, spots_df, output_path, circle_radius=4,
                                        circle_color='yellow', linewidth=1.0,
                                        scale_bar_um=None, dynamic_range=None,
                                        channel_name=None):
    """
    Save an RGB image as SVG with spot circles as vector elements (not baked in).

    This creates cleaner circles that can be adjusted in SVG editors.

    Args:
        rgb: RGB image as numpy array (H, W, 3) uint8
        spots_df: DataFrame with 'pos_x' and 'pos_y' columns
        output_path: Path to save the SVG
        circle_radius: Radius of circles in pixels
        circle_color: Color for circles (matplotlib color string or RGB tuple)
        linewidth: Line width for circle outlines
        scale_bar_um: Optional scale bar length in micrometers
        dynamic_range: Optional tuple (vmin, vmax) for annotation
        channel_name: Optional channel name for annotation
    """
    import matplotlib.pyplot as plt
    from matplotlib.patches import Circle

    if scale_bar_um is None:
        scale_bar_um = SCALE_BAR_OVERVIEW

    cfg = FigureConfig

    # Create figure
    fig_width = 4.0  # inches
    aspect = rgb.shape[0] / rgb.shape[1]
    fig, ax = plt.subplots(figsize=(fig_width, fig_width * aspect))
    ax.imshow(rgb)
    ax.axis('off')

    # Convert color tuple to matplotlib format if needed
    if isinstance(circle_color, tuple):
        circle_color = tuple(c / 255.0 for c in circle_color)

    # Add circles as vector elements
    if spots_df is not None and len(spots_df) > 0:
        for _, spot in spots_df.iterrows():
            x = spot['pos_x']
            y = spot['pos_y']
            circle = Circle((x, y), circle_radius,
                           facecolor='none', edgecolor=circle_color,
                           linewidth=linewidth)
            ax.add_patch(circle)

    # Add scale bar
    scale_bar_px = int(scale_bar_um / PIXEL_SIZE_XY)
    img_h, img_w = rgb.shape[:2]
    bar_height = max(5, int(img_h * 0.015))
    padding = max(10, int(img_w * 0.02))

    bar_x = img_w - padding - scale_bar_px
    bar_y = img_h - padding - bar_height

    from matplotlib.patches import Rectangle
    scale_bar_rect = Rectangle((bar_x, bar_y), scale_bar_px, bar_height,
                                 facecolor='white', edgecolor='none')
    ax.add_patch(scale_bar_rect)
    ax.text(bar_x + scale_bar_px/2, bar_y - 3, f'{scale_bar_um} µm',
           color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK,
           ha='center', va='bottom')

    # Add dynamic range annotation if provided
    if dynamic_range is not None:
        dr_text = f'{dynamic_range[0]:.0f}-{dynamic_range[1]:.0f}'
        if channel_name:
            dr_text = f'{channel_name}: {dr_text}'
        ax.text(padding, padding, dr_text,
               color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.7))

    plt.tight_layout(pad=0.1)

    # Save as SVG
    svg_path = str(output_path)
    if not svg_path.endswith('.svg'):
        svg_path = svg_path.replace('.tif', '.svg').replace('.png', '.svg')
        if not svg_path.endswith('.svg'):
            svg_path = svg_path + '.svg'
    plt.savefig(svg_path, format='svg', bbox_inches='tight')
    plt.close()

    return svg_path


def save_merged_svg_with_vector_circles(rgb, spots_green_df, spots_orange_df, output_path,
                                         circle_radius=4, linewidth=1.0,
                                         scale_bar_um=None, green_range=None, orange_range=None):
    """
    Save a merged RGB image as SVG with spot circles for both channels as vector elements.

    Args:
        rgb: RGB image as numpy array (H, W, 3) uint8
        spots_green_df: DataFrame with green spot positions
        spots_orange_df: DataFrame with orange spot positions
        output_path: Path to save the SVG
        circle_radius: Radius of circles in pixels
        linewidth: Line width for circle outlines
        scale_bar_um: Optional scale bar length in micrometers
        green_range: Optional (vmin, vmax) for green channel
        orange_range: Optional (vmin, vmax) for orange channel
    """
    import matplotlib.pyplot as plt
    from matplotlib.patches import Circle, Rectangle

    if scale_bar_um is None:
        scale_bar_um = SCALE_BAR_OVERVIEW

    cfg = FigureConfig

    # Create figure
    fig_width = 4.0
    aspect = rgb.shape[0] / rgb.shape[1]
    fig, ax = plt.subplots(figsize=(fig_width, fig_width * aspect))
    ax.imshow(rgb)
    ax.axis('off')

    # Add green circles (yellow color for visibility)
    if spots_green_df is not None and len(spots_green_df) > 0:
        for _, spot in spots_green_df.iterrows():
            x = spot['pos_x']
            y = spot['pos_y']
            circle = Circle((x, y), circle_radius,
                           facecolor='none', edgecolor='yellow',
                           linewidth=linewidth)
            ax.add_patch(circle)

    # Add orange circles (cyan color for visibility)
    if spots_orange_df is not None and len(spots_orange_df) > 0:
        for _, spot in spots_orange_df.iterrows():
            x = spot['pos_x']
            y = spot['pos_y']
            circle = Circle((x, y), circle_radius,
                           facecolor='none', edgecolor='cyan',
                           linewidth=linewidth)
            ax.add_patch(circle)

    # Add scale bar
    scale_bar_px = int(scale_bar_um / PIXEL_SIZE_XY)
    img_h, img_w = rgb.shape[:2]
    bar_height = max(5, int(img_h * 0.015))
    padding = max(10, int(img_w * 0.02))

    bar_x = img_w - padding - scale_bar_px
    bar_y = img_h - padding - bar_height

    scale_bar_rect = Rectangle((bar_x, bar_y), scale_bar_px, bar_height,
                                 facecolor='white', edgecolor='none')
    ax.add_patch(scale_bar_rect)
    ax.text(bar_x + scale_bar_px/2, bar_y - 3, f'{scale_bar_um} µm',
           color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK,
           ha='center', va='bottom')

    # Add dynamic range annotations
    y_offset = padding
    line_height = 18

    if green_range is not None:
        ax.text(padding, y_offset, f'Green: {green_range[0]:.0f}-{green_range[1]:.0f}',
               color='lime', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.7))
        y_offset += line_height

    if orange_range is not None:
        ax.text(padding, y_offset, f'Orange: {orange_range[0]:.0f}-{orange_range[1]:.0f}',
               color='orange', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.7))

    plt.tight_layout(pad=0.1)

    # Save as SVG
    svg_path = str(output_path)
    if not svg_path.endswith('.svg'):
        svg_path = svg_path.replace('.tif', '.svg').replace('.png', '.svg')
        if not svg_path.endswith('.svg'):
            svg_path = svg_path + '.svg'
    plt.savefig(svg_path, format='svg', bbox_inches='tight')
    plt.close()

    return svg_path


def save_zoom_svg_with_threshold_circles(rgb, passed_spots_df, failed_spots_df, output_path,
                                          circle_radius=3, linewidth=1.0, scale_bar_um=None,
                                          dynamic_range=None, channel_name=None):
    """
    Save a zoom image as SVG with threshold-colored spot circles as vector elements.

    Passed spots are shown in white, failed spots in red.

    Args:
        rgb: RGB image as numpy array (H, W, 3) uint8
        passed_spots_df: DataFrame with spots that passed threshold
        failed_spots_df: DataFrame with spots that failed threshold
        output_path: Path to save the SVG
        circle_radius: Radius of circles in pixels
        linewidth: Line width for circle outlines
        scale_bar_um: Optional scale bar length in micrometers (default: SCALE_BAR_ZOOM)
        dynamic_range: Optional tuple (vmin, vmax) for annotation
        channel_name: Optional channel name for annotation
    """
    import matplotlib.pyplot as plt
    from matplotlib.patches import Circle, Rectangle

    if scale_bar_um is None:
        scale_bar_um = SCALE_BAR_ZOOM

    cfg = FigureConfig

    # Create figure
    fig_width = 4.0  # inches
    aspect = rgb.shape[0] / rgb.shape[1]
    fig, ax = plt.subplots(figsize=(fig_width, fig_width * aspect))
    ax.imshow(rgb)
    ax.axis('off')

    # Add failed spots first (red), so passed spots (white) are on top
    if failed_spots_df is not None and len(failed_spots_df) > 0:
        for _, spot in failed_spots_df.iterrows():
            x = spot['pos_x']
            y = spot['pos_y']
            circle = Circle((x, y), circle_radius,
                           facecolor='none', edgecolor=(1.0, 0.2, 0.2),  # Red
                           linewidth=linewidth)
            ax.add_patch(circle)

    # Add passed spots (white) on top
    if passed_spots_df is not None and len(passed_spots_df) > 0:
        for _, spot in passed_spots_df.iterrows():
            x = spot['pos_x']
            y = spot['pos_y']
            circle = Circle((x, y), circle_radius,
                           facecolor='none', edgecolor='white',
                           linewidth=linewidth)
            ax.add_patch(circle)

    # Add scale bar
    scale_bar_px = int(scale_bar_um / PIXEL_SIZE_XY)
    img_h, img_w = rgb.shape[:2]
    bar_height = max(3, int(img_h * 0.02))
    padding = max(8, int(img_w * 0.03))

    bar_x = img_w - padding - scale_bar_px
    bar_y = img_h - padding - bar_height

    scale_bar_rect = Rectangle((bar_x, bar_y), scale_bar_px, bar_height,
                                 facecolor='white', edgecolor='none')
    ax.add_patch(scale_bar_rect)
    ax.text(bar_x + scale_bar_px/2, bar_y - 2, f'{scale_bar_um} µm',
           color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
           ha='center', va='bottom')

    # Add dynamic range annotation if provided
    if dynamic_range is not None:
        dr_text = f'{dynamic_range[0]:.0f}-{dynamic_range[1]:.0f}'
        if channel_name:
            dr_text = f'{channel_name}: {dr_text}'
        ax.text(padding, padding, dr_text,
               color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK - 2,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.7))

    plt.tight_layout(pad=0.1)

    # Save as SVG
    svg_path = str(output_path)
    if not svg_path.endswith('.svg'):
        svg_path = svg_path.replace('.tif', '.svg').replace('.png', '.svg')
        if not svg_path.endswith('.svg'):
            svg_path = svg_path + '.svg'
    plt.savefig(svg_path, format='svg', bbox_inches='tight')
    plt.close()

    return svg_path


def extract_spot_zoom(stack, pos_x, pos_y, pos_z, box_size=30):
    """
    Extract a zoomed region around a spot from the 3D stack.

    Args:
        stack: 3D array (z, y, x)
        pos_x, pos_y, pos_z: Actual pixel coordinates in the image
        box_size: Size of the zoom box in pixels

    Returns:
        2D max projection of the zoomed region
    """
    z, y, x = int(round(pos_z)), int(round(pos_y)), int(round(pos_x))
    half = box_size // 2

    # Get bounds with clipping
    z_min = max(0, z - 3)
    z_max = min(stack.shape[0], z + 4)
    y_min = max(0, y - half)
    y_max = min(stack.shape[1], y + half)
    x_min = max(0, x - half)
    x_max = min(stack.shape[2], x + half)

    # Extract region and max project
    region = stack[z_min:z_max, y_min:y_max, x_min:x_max]
    return np.max(region, axis=0)


def extract_zoom_region(projection, center_x, center_y, box_size=200):
    """
    Extract a zoomed region from a 2D projection.

    Args:
        projection: 2D array (y, x)
        center_x, center_y: Center of the zoom region
        box_size: Size of the zoom box in pixels

    Returns:
        2D cropped region and bounds (x_min, x_max, y_min, y_max)
    """
    y, x = int(round(center_y)), int(round(center_x))
    half = box_size // 2

    # Get bounds with clipping
    y_min = max(0, y - half)
    y_max = min(projection.shape[0], y + half)
    x_min = max(0, x - half)
    x_max = min(projection.shape[1], x + half)

    # Extract region
    region = projection[y_min:y_max, x_min:x_max]
    return region, (x_min, x_max, y_min, y_max)


def find_spot_cluster_center(spots_df, n_neighbors=10, min_spots=5):
    """
    Find a good center location for zoom where spots are clustered.

    Args:
        spots_df: DataFrame with pos_x, pos_y columns
        n_neighbors: Consider density in this radius
        min_spots: Minimum spots needed

    Returns:
        (center_x, center_y) or None if not enough spots
    """
    if len(spots_df) < min_spots:
        return None

    # Simple approach: find spot with most neighbors
    coords = spots_df[['pos_x', 'pos_y']].values
    best_idx = 0
    best_count = 0

    for i, (x, y) in enumerate(coords):
        # Count spots within radius of 100 pixels
        distances = np.sqrt((coords[:, 0] - x)**2 + (coords[:, 1] - y)**2)
        count = np.sum(distances < 100)
        if count > best_count:
            best_count = count
            best_idx = i

    return coords[best_idx, 0], coords[best_idx, 1]


def save_zoom_with_spots(projection, spots_df, center_x, center_y, box_size,
                          output_path, circle_radius=5, circle_color=(255, 255, 0),
                          spots_sigma_df=None, colorbar_label='sigma_x (pixels)',
                          channel='green'):
    """
    Save a zoomed region with spot circles as VECTOR elements in SVG.

    Circles are drawn as matplotlib Circle patches (vector graphics), NOT baked into the image.

    Output is SVG format with:
    - Grayscale colorbar (white to 75% dark) for sigma values
    - Dynamic range text box showing image intensity range
    - Scale bar
    - Vector circles for spots (editable in SVG editors)

    Args:
        projection: 2D image
        spots_df: DataFrame with pos_x, pos_y columns (used for filtering region)
        center_x, center_y: Center of zoom region
        box_size: Size of zoom box
        output_path: Where to save (will be saved as SVG)
        circle_radius: Radius for circles
        circle_color: RGB color for circles (used if spots_sigma_df is None)
        spots_sigma_df: Optional DataFrame with pos_x, pos_y, sigma_x columns
                        If provided, circles are colored by sigma_x value
        colorbar_label: Label for the colorbar
        channel: 'green' or 'orange' - determines background color

    Returns:
        Number of spots in the zoom region
    """
    import matplotlib.pyplot as plt
    import matplotlib.colors as mcolors
    from matplotlib.colors import LinearSegmentedColormap
    from matplotlib.patches import Circle, Rectangle

    # Extract region
    region, (x_min, x_max, y_min, y_max) = extract_zoom_region(
        projection, center_x, center_y, box_size
    )

    # Get dynamic range BEFORE normalization
    dynamic_range = (region.min(), region.max())

    # Normalize and convert to RGB with channel-appropriate coloring
    region_norm = normalize_image(region)
    region_8bit = (region_norm * 255).astype(np.uint8)

    # Create colored background based on channel (CLEAN - no circles baked in)
    rgb = np.zeros((*region_8bit.shape, 3), dtype=np.uint8)
    if channel == 'green':
        rgb[:, :, 1] = region_8bit  # Green channel
    elif channel == 'orange':
        # Orange = RGB(255, 165, 0) normalized
        rgb[:, :, 0] = region_8bit  # Red
        rgb[:, :, 1] = (region_norm * 165).astype(np.uint8)  # Green (scaled)
    else:
        # Default to grayscale
        rgb = np.stack([region_8bit, region_8bit, region_8bit], axis=-1)

    # Filter spots to those in this region
    mask = (
        (spots_df['pos_x'] >= x_min) & (spots_df['pos_x'] < x_max) &
        (spots_df['pos_y'] >= y_min) & (spots_df['pos_y'] < y_max)
    )
    spots_in_region = spots_df[mask].copy()

    # Adjust coordinates to local region
    spots_in_region['local_x'] = spots_in_region['pos_x'] - x_min
    spots_in_region['local_y'] = spots_in_region['pos_y'] - y_min

    # Check if we have sigma data for coloring
    use_sigma_coloring = False
    if spots_sigma_df is not None and 'sigma_x' in spots_sigma_df.columns:
        # Filter sigma spots to region
        sigma_mask = (
            (spots_sigma_df['pos_x'] >= x_min) & (spots_sigma_df['pos_x'] < x_max) &
            (spots_sigma_df['pos_y'] >= y_min) & (spots_sigma_df['pos_y'] < y_max)
        )
        sigma_in_region = spots_sigma_df[sigma_mask].copy()
        if len(sigma_in_region) > 0:
            sigma_in_region['local_x'] = sigma_in_region['pos_x'] - x_min
            sigma_in_region['local_y'] = sigma_in_region['pos_y'] - y_min
            use_sigma_coloring = True
            # Use sigma spots instead
            spots_in_region = sigma_in_region

    cfg = FigureConfig

    if use_sigma_coloring:
        # Convert sigma from pixels to nm (pixel size = 162.5 nm)
        PIXEL_SIZE_NM = PIXEL_SIZE_XY * 1000  # 162.5 nm per pixel
        sigma_nm = spots_in_region['sigma_x'] * PIXEL_SIZE_NM

        # Create grayscale colormap: white (1.0) to 75% dark (0.25)
        # Low sigma values = white, high sigma values = dark gray
        cmap = LinearSegmentedColormap.from_list('white_to_dark',
                                                   [(1.0, 1.0, 1.0), (0.25, 0.25, 0.25)])
        sigma_min = sigma_nm.min()
        sigma_max = sigma_nm.max()
        norm = mcolors.Normalize(vmin=sigma_min, vmax=sigma_max)

        # Create figure with colorbar on TOP
        fig, (ax_cbar, ax_img) = plt.subplots(2, 1, figsize=(2.5, 3.0),
                                               gridspec_kw={'height_ratios': [1, 15]})
        ax_img.imshow(rgb)
        ax_img.axis('off')

        # Add circles as VECTOR elements (not baked into the image)
        for idx, (_, spot) in enumerate(spots_in_region.iterrows()):
            x = spot['local_x']
            y = spot['local_y']

            if 0 <= x < rgb.shape[1] and 0 <= y < rgb.shape[0]:
                # Get color from colormap (using nm value)
                sigma_val_nm = sigma_nm.iloc[idx]
                rgba = cmap(norm(sigma_val_nm))
                color = rgba[:3]  # RGB tuple (0-1 range)

                # Add circle as vector element
                circle = Circle((x, y), circle_radius,
                               facecolor='none', edgecolor=color,
                               linewidth=1.5)
                ax_img.add_patch(circle)

        # Add scale bar (10 µm for zoom images)
        scale_bar_um = SCALE_BAR_ZOOM
        scale_bar_px = int(scale_bar_um / PIXEL_SIZE_XY)
        img_h, img_w = rgb.shape[:2]
        bar_height = 5
        padding = 10

        # Draw scale bar in bottom right
        bar_x = img_w - padding - scale_bar_px
        bar_y = img_h - padding - bar_height
        scale_bar_rect = Rectangle((bar_x, bar_y), scale_bar_px, bar_height,
                                     facecolor='white', edgecolor='none')
        ax_img.add_patch(scale_bar_rect)

        # Add scale bar label
        ax_img.text(bar_x + scale_bar_px/2, bar_y - 3, f'{scale_bar_um} µm',
                   color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
                   ha='center', va='bottom')

        # Add dynamic range text box in top left
        dr_text = f'Range: {dynamic_range[0]:.0f}-{dynamic_range[1]:.0f}'
        ax_img.text(5, 5, dr_text, color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
                   ha='left', va='top',
                   bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7))

        # Add horizontal colorbar on top with proper styling
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])
        cbar = fig.colorbar(sm, cax=ax_cbar, orientation='horizontal')
        cbar.set_label('σₓ (nm)', fontsize=cfg.FONT_SIZE_AXIS_LABEL)
        ax_cbar.xaxis.set_ticks_position('top')
        ax_cbar.xaxis.set_label_position('top')
        cbar.ax.tick_params(labelsize=cfg.FONT_SIZE_AXIS_TICK)

        plt.tight_layout(pad=0.3)

        # Save as SVG (change extension if needed)
        svg_path = str(output_path).replace('.png', '.svg').replace('.tif', '.svg')
        if not svg_path.endswith('.svg'):
            svg_path = svg_path + '.svg'
        plt.savefig(svg_path, format='svg', bbox_inches='tight')
        plt.close()
    else:
        # Use matplotlib for SVG output with scale bar, dynamic range, and VECTOR circles
        fig, ax = plt.subplots(figsize=(2.5, 2.5))
        ax.imshow(rgb)
        ax.axis('off')

        # Convert circle_color to matplotlib format if needed (0-1 range)
        if isinstance(circle_color, tuple) and max(circle_color) > 1:
            mpl_color = tuple(c / 255.0 for c in circle_color)
        else:
            mpl_color = circle_color

        # Add circles as VECTOR elements (not baked into the image)
        for _, spot in spots_in_region.iterrows():
            x = spot['local_x']
            y = spot['local_y']

            if 0 <= x < rgb.shape[1] and 0 <= y < rgb.shape[0]:
                circle = Circle((x, y), circle_radius,
                               facecolor='none', edgecolor=mpl_color,
                               linewidth=1.5)
                ax.add_patch(circle)

        # Add scale bar
        scale_bar_um = SCALE_BAR_ZOOM
        scale_bar_px = int(scale_bar_um / PIXEL_SIZE_XY)
        img_h, img_w = rgb.shape[:2]
        bar_height = 5
        padding = 10

        bar_x = img_w - padding - scale_bar_px
        bar_y = img_h - padding - bar_height
        scale_bar_rect = Rectangle((bar_x, bar_y), scale_bar_px, bar_height,
                                     facecolor='white', edgecolor='none')
        ax.add_patch(scale_bar_rect)
        ax.text(bar_x + scale_bar_px/2, bar_y - 3, f'{scale_bar_um} µm',
               color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='center', va='bottom')

        # Add dynamic range text box
        dr_text = f'Range: {dynamic_range[0]:.0f}-{dynamic_range[1]:.0f}'
        ax.text(5, 5, dr_text, color='white', fontsize=cfg.FONT_SIZE_AXIS_TICK - 1,
               ha='left', va='top',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7))

        plt.tight_layout(pad=0.1)

        # Save as SVG
        svg_path = str(output_path).replace('.png', '.svg').replace('.tif', '.svg')
        if not svg_path.endswith('.svg'):
            svg_path = svg_path + '.svg'
        plt.savefig(svg_path, format='svg', bbox_inches='tight')
        plt.close()

    return len(spots_in_region)


def print_fov_metadata(row: pd.Series, title: str = ""):
    """Print comprehensive metadata for a FOV."""
    print(f"\n{'─'*80}")
    if title:
        print(f"  {title}")
        print(f"{'─'*80}")
    print(f"  FOV Key: {row['fov_key']}")
    print(f"  Slide: {row['slide_std']} | Mouse: {row.get('mouse_id', 'N/A')}")
    print(f"  Genotype: {row.get('mouse_model', 'N/A')} | Age: {row.get('age', 'N/A')} months")
    print(f"  Region: {row.get('brain_region', 'N/A')}")
    print(f"  Probe Set: {row.get('probe_set', 'N/A')}")
    print(f"  Nuclei: {row.get('num_cells', 0):.0f} | Total spots: {row.get('total_spots', 0):.0f}")
    print(f"  Green spots: {row.get('green_spots', 0):.0f} | Orange spots: {row.get('orange_spots', 0):.0f}")

    # Get NPZ path
    original_fov = row.get('original_fov_num', None)
    npz_path = find_npz_path(row['slide_raw'], row['region_num'], row['fov_num'], original_fov)
    if npz_path:
        print(f"  NPZ: {Path(npz_path).name}")
    print(f"{'─'*80}")


# ══════════════════════════════════════════════════════════════════════════════
# PANEL B: Negative Control FOVs
# ══════════════════════════════════════════════════════════════════════════════

def generate_panel_B(df: pd.DataFrame, n_images: int = 3):
    """
    Generate negative control images for Panel B.

    Negative controls should show minimal/no mHTT signal despite having good tissue.

    Output structure:
        panel_B/
            fov_1/
                DAPI.tif, mHTT1a.tif, full_length.tif, merged.tif, metadata.txt
            fov_2/
                ...
    """
    print("\n" + "="*80)
    print("PANEL B: Negative Control FOVs")
    print("="*80)

    # Create panel directory
    panel_dir = OUTPUT_DIR / 'panel_B'
    panel_dir.mkdir(parents=True, exist_ok=True)

    # Filter for negative controls with decent tissue quality
    df_neg = filter_fovs(df, probe_type='negative_control', min_nuclei=50)

    if len(df_neg) == 0:
        print("  ERROR: No negative control FOVs found!")
        return

    # Sort by lowest total spots (best negative controls have fewest spots)
    df_neg = df_neg.sort_values('total_spots', ascending=True).head(n_images * 2)

    print(f"  Found {len(df_neg)} negative control FOVs")

    saved = 0
    used_exp_fov_keys = set()  # Track used experimental FOVs to avoid duplicates

    for idx, (_, row) in enumerate(df_neg.iterrows()):
        if saved >= n_images:
            break

        original_fov = row.get('original_fov_num', None)
        npz_path = find_npz_path(row['slide_raw'], row['region_num'], row['fov_num'], original_fov)

        if npz_path is None:
            continue

        print_fov_metadata(row, f"Negative Control {saved + 1}")

        # Create FOV directory
        fov_dir = panel_dir / f'fov_{saved + 1}'
        fov_dir.mkdir(parents=True, exist_ok=True)

        # Load and save images
        projections, _ = load_and_project_npz(npz_path)

        # ─────────────────────────────────────────────────────────────────────
        # Find experimental FOV from same slide for comparison (avoid duplicates)
        # ─────────────────────────────────────────────────────────────────────
        neg_slide = row['slide_std']
        exp_row, exp_npz_path = find_experimental_for_negative_control(df, neg_slide, used_exp_fov_keys)

        if exp_npz_path is not None:
            print(f"    Found experimental comparison from slide {exp_row['slide_std']}, FOV: {exp_row['fov_key'][:50]}...")
            used_exp_fov_keys.add(exp_row['fov_key'])  # Mark this experimental FOV as used
            exp_projections, _ = load_and_project_npz(exp_npz_path)

            # Compute dynamic range from EXPERIMENTAL images
            blue_range = compute_dynamic_range(exp_projections['blue'])
            green_range = compute_dynamic_range(exp_projections['green'])
            orange_range = compute_dynamic_range(exp_projections['orange'])

            # Save EXPERIMENTAL images as TIFF (no scale bar, no dynamic range annotations)
            save_colored_tiff(exp_projections['blue'], fov_dir / "experimental_DAPI.tif", 'blue')
            save_colored_tiff(exp_projections['green'], fov_dir / "experimental_mHTT1a.tif", 'green')
            save_colored_tiff(exp_projections['orange'], fov_dir / "experimental_full_length.tif", 'orange')
            save_rgb_tiff(exp_projections['blue'], exp_projections['green'], exp_projections['orange'],
                          fov_dir / "experimental_merged.tif")

            # Save EXPERIMENTAL images as SVG with scale bar and dynamic range annotations
            save_image_as_svg(exp_projections['green'], fov_dir / "experimental_mHTT1a.svg",
                              dynamic_range=green_range, channel='green')
            save_image_as_svg(exp_projections['orange'], fov_dir / "experimental_full_length.svg",
                              dynamic_range=orange_range, channel='orange')
            exp_merged_rgb = create_merged_rgb(exp_projections['blue'], exp_projections['green'],
                                                exp_projections['orange'])
            save_composite_svg(exp_merged_rgb, fov_dir / "experimental_merged.svg",
                               green_range=green_range, orange_range=orange_range)

            # ─────────────────────────────────────────────────────────────────────
            # Load and display spots with passed/failed threshold
            # Uses spots (not spots_sigma_var) to match figure1.py logic
            # ─────────────────────────────────────────────────────────────────────
            thresholds = load_photon_thresholds()
            exp_slide = exp_row['slide_std']
            exp_fov_key = exp_row['fov_key']

            for channel, channel_name in [('green', 'mHTT1a'), ('orange', 'full_length')]:
                # Load experimental spots with threshold classification
                exp_passed, exp_failed = load_all_spots_with_threshold(
                    exp_fov_key, exp_slide, channel, thresholds=thresholds
                )

                # Load negative control spots (use same slide's threshold)
                neg_passed, neg_failed = load_all_spots_with_threshold(
                    row['fov_key'], exp_slide, channel, thresholds=thresholds
                )

                # Create color-coded image base
                img_norm = normalize_image(exp_projections[channel])
                shape = exp_projections[channel].shape
                rgb = np.zeros((*shape, 3), dtype=np.uint8)
                if channel == 'green':
                    rgb[:, :, 1] = (img_norm * 255).astype(np.uint8)
                else:  # orange
                    rgb[:, :, 0] = (img_norm * 255).astype(np.uint8)
                    rgb[:, :, 1] = (img_norm * 165).astype(np.uint8)

                # Draw spots: passed=white, failed=red
                if len(exp_failed) > 0:
                    rgb = draw_spot_circles(rgb, exp_failed, radius=3, color=(255, 50, 50))  # Red for failed
                if len(exp_passed) > 0:
                    rgb = draw_spot_circles(rgb, exp_passed, radius=3, color=(255, 255, 255))  # White for passed

                # Save TIFF without scale bar
                imwrite(str(fov_dir / f"experimental_{channel_name}_with_spots.tif"), rgb)
                print(f"    Exp {channel_name}: {len(exp_passed)} passed, {len(exp_failed)} failed threshold")

                # Same for negative control - AUTO RANGE version
                img_norm_neg = normalize_image(projections[channel])
                rgb_neg = np.zeros((*shape, 3), dtype=np.uint8)
                if channel == 'green':
                    rgb_neg[:, :, 1] = (img_norm_neg * 255).astype(np.uint8)
                else:  # orange
                    rgb_neg[:, :, 0] = (img_norm_neg * 255).astype(np.uint8)
                    rgb_neg[:, :, 1] = (img_norm_neg * 165).astype(np.uint8)

                if len(neg_failed) > 0:
                    rgb_neg = draw_spot_circles(rgb_neg, neg_failed, radius=3, color=(255, 50, 50))
                if len(neg_passed) > 0:
                    rgb_neg = draw_spot_circles(rgb_neg, neg_passed, radius=3, color=(255, 255, 255))

                # Save TIFF without scale bar
                imwrite(str(fov_dir / f"negative_{channel_name}_with_spots.tif"), rgb_neg)

                # Negative control with spots - MATCHED RANGE version (uses experimental dynamic range)
                ch_range = green_range if channel == 'green' else orange_range
                vmin, vmax = ch_range
                neg_img = projections[channel].astype(np.float32)
                img_norm_neg_matched = np.clip((neg_img - vmin) / (vmax - vmin), 0, 1)
                rgb_neg_matched = np.zeros((*shape, 3), dtype=np.uint8)
                if channel == 'green':
                    rgb_neg_matched[:, :, 1] = (img_norm_neg_matched * 255).astype(np.uint8)
                else:  # orange
                    rgb_neg_matched[:, :, 0] = (img_norm_neg_matched * 255).astype(np.uint8)
                    rgb_neg_matched[:, :, 1] = (img_norm_neg_matched * 165).astype(np.uint8)

                if len(neg_failed) > 0:
                    rgb_neg_matched = draw_spot_circles(rgb_neg_matched, neg_failed, radius=3, color=(255, 50, 50))
                if len(neg_passed) > 0:
                    rgb_neg_matched = draw_spot_circles(rgb_neg_matched, neg_passed, radius=3, color=(255, 255, 255))

                # Save TIFF without scale bar
                imwrite(str(fov_dir / f"negative_{channel_name}_with_spots_matched_range.tif"), rgb_neg_matched)

                print(f"    Neg {channel_name}: {len(neg_passed)} passed, {len(neg_failed)} failed threshold")

            # Compute negative control dynamic ranges (for auto-range images)
            neg_blue_range = compute_dynamic_range(projections['blue'])
            neg_green_range = compute_dynamic_range(projections['green'])
            neg_orange_range = compute_dynamic_range(projections['orange'])
            neg_merged_range = (min(neg_green_range[0], neg_orange_range[0]),
                                max(neg_green_range[1], neg_orange_range[1]))

            # Experimental merged range (for matched range images)
            exp_merged_range = (min(green_range[0], orange_range[0]),
                                max(green_range[1], orange_range[1]))

            # Save NEGATIVE CONTROL with MATCHED RANGE as TIFF (no annotations)
            save_colored_tiff(projections['blue'], fov_dir / "negative_DAPI_matched_range.tif",
                              'blue', img_range=blue_range)
            save_colored_tiff(projections['green'], fov_dir / "negative_mHTT1a_matched_range.tif",
                              'green', img_range=green_range)
            save_colored_tiff(projections['orange'], fov_dir / "negative_full_length_matched_range.tif",
                              'orange', img_range=orange_range)
            save_rgb_tiff(projections['blue'], projections['green'], projections['orange'],
                          fov_dir / "negative_merged_matched_range.tif",
                          blue_range=blue_range, green_range=green_range, orange_range=orange_range)

            # Save NEGATIVE CONTROL as SVG with MATCHED RANGE (shows EXPERIMENTAL range used for normalization)
            save_image_as_svg(projections['green'], fov_dir / "negative_mHTT1a_matched_range.svg",
                              dynamic_range=green_range, channel='green', img_range=green_range)
            save_image_as_svg(projections['orange'], fov_dir / "negative_full_length_matched_range.svg",
                              dynamic_range=orange_range, channel='orange', img_range=orange_range)
            neg_merged_rgb = create_merged_rgb(projections['blue'], projections['green'], projections['orange'],
                                                blue_range=blue_range, green_range=green_range, orange_range=orange_range)
            save_composite_svg(neg_merged_rgb, fov_dir / "negative_merged_matched_range.svg",
                               green_range=green_range, orange_range=orange_range)

            # Save NEGATIVE CONTROL with AUTO RANGE as TIFF (no annotations)
            save_colored_tiff(projections['blue'], fov_dir / "negative_DAPI_auto_range.tif", 'blue')
            save_colored_tiff(projections['green'], fov_dir / "negative_mHTT1a_auto_range.tif", 'green')
            save_colored_tiff(projections['orange'], fov_dir / "negative_full_length_auto_range.tif", 'orange')
            save_rgb_tiff(projections['blue'], projections['green'], projections['orange'],
                          fov_dir / "negative_merged_auto_range.tif")

            # Save NEGATIVE CONTROL as SVG with AUTO RANGE (shows negative control's OWN range)
            save_image_as_svg(projections['green'], fov_dir / "negative_mHTT1a_auto_range.svg",
                              dynamic_range=neg_green_range, channel='green')
            save_image_as_svg(projections['orange'], fov_dir / "negative_full_length_auto_range.svg",
                              dynamic_range=neg_orange_range, channel='orange')
            neg_merged_auto_rgb = create_merged_rgb(projections['blue'], projections['green'], projections['orange'])
            save_composite_svg(neg_merged_auto_rgb, fov_dir / "negative_merged_auto_range.svg",
                               green_range=neg_green_range, orange_range=neg_orange_range)

            # ─────────────────────────────────────────────────────────────────────
            # Generate zoom images of the same region for both exp and neg control
            # ─────────────────────────────────────────────────────────────────────
            zoom_size = 256
            img_h, img_w = projections['green'].shape

            # Define multiple zoom locations for selection
            zoom_locations = [
                ('center', img_w // 2, img_h // 2),
                ('upper_left', img_w // 4, img_h // 4),
                ('upper_right', 3 * img_w // 4, img_h // 4),
                ('lower_left', img_w // 4, 3 * img_h // 4),
                ('lower_right', 3 * img_w // 4, 3 * img_h // 4),
            ]

            # Helper function to filter spots to zoom region
            def filter_spots_to_zoom(spots_df, x_min, x_max, y_min, y_max):
                if spots_df is None or len(spots_df) == 0:
                    return pd.DataFrame()
                mask = (spots_df['pos_x'] >= x_min) & (spots_df['pos_x'] < x_max) & \
                       (spots_df['pos_y'] >= y_min) & (spots_df['pos_y'] < y_max)
                zoom_spots = spots_df[mask].copy()
                if len(zoom_spots) > 0:
                    zoom_spots['pos_x'] = zoom_spots['pos_x'] - x_min
                    zoom_spots['pos_y'] = zoom_spots['pos_y'] - y_min
                return zoom_spots

            for zoom_name, cx, cy in zoom_locations:
                # Create zoom directory for this location
                zoom_dir = fov_dir / f'zoom_comparison_{zoom_name}'
                zoom_dir.mkdir(parents=True, exist_ok=True)

                for channel, channel_name in [('green', 'mHTT1a'), ('orange', 'full_length')]:
                    # Get dynamic range from experimental
                    if channel == 'green':
                        ch_range = green_range
                    else:
                        ch_range = orange_range

                    # Extract zoom regions
                    exp_region, (x_min, x_max, y_min, y_max) = extract_zoom_region(
                        exp_projections[channel], cx, cy, zoom_size
                    )
                    neg_region, _ = extract_zoom_region(
                        projections[channel], cx, cy, zoom_size
                    )

                    # Save zoom images as TIFF (no scale bar)
                    save_colored_tiff(exp_region, zoom_dir / f"experimental_{channel_name}_zoom.tif",
                                      channel)
                    save_colored_tiff(neg_region, zoom_dir / f"negative_{channel_name}_zoom_matched_range.tif",
                                      channel, img_range=ch_range)
                    save_colored_tiff(neg_region, zoom_dir / f"negative_{channel_name}_zoom_auto_range.tif",
                                      channel)

                    # Get spots for this channel (reload for zoom)
                    exp_passed_zoom, exp_failed_zoom = load_all_spots_with_threshold(
                        exp_fov_key, exp_slide, channel, thresholds=thresholds
                    )
                    neg_passed_zoom, neg_failed_zoom = load_all_spots_with_threshold(
                        row['fov_key'], exp_slide, channel, thresholds=thresholds
                    )

                    exp_passed_in_zoom = filter_spots_to_zoom(exp_passed_zoom, x_min, x_max, y_min, y_max)
                    exp_failed_in_zoom = filter_spots_to_zoom(exp_failed_zoom, x_min, x_max, y_min, y_max)
                    neg_passed_in_zoom = filter_spots_to_zoom(neg_passed_zoom, x_min, x_max, y_min, y_max)
                    neg_failed_in_zoom = filter_spots_to_zoom(neg_failed_zoom, x_min, x_max, y_min, y_max)

                    # Create experimental zoom with spots
                    shape = exp_region.shape
                    vmin, vmax = ch_range
                    exp_norm = np.clip((exp_region.astype(np.float32) - vmin) / (vmax - vmin), 0, 1)
                    rgb_exp_zoom = np.zeros((*shape, 3), dtype=np.uint8)
                    if channel == 'green':
                        rgb_exp_zoom[:, :, 1] = (exp_norm * 255).astype(np.uint8)
                    else:  # orange
                        rgb_exp_zoom[:, :, 0] = (exp_norm * 255).astype(np.uint8)
                        rgb_exp_zoom[:, :, 1] = (exp_norm * 165).astype(np.uint8)

                    # Save clean TIFF (no circles)
                    imwrite(str(zoom_dir / f"experimental_{channel_name}_zoom.tif"), rgb_exp_zoom)

                    # Save SVG with vector circles (white=passed, red=failed)
                    save_zoom_svg_with_threshold_circles(
                        rgb_exp_zoom, exp_passed_in_zoom, exp_failed_in_zoom,
                        zoom_dir / f"experimental_{channel_name}_zoom_with_spots.svg",
                        circle_radius=3, dynamic_range=ch_range, channel_name=channel_name
                    )

                    # Create negative zoom with spots (matched range)
                    neg_norm_matched = np.clip((neg_region.astype(np.float32) - vmin) / (vmax - vmin), 0, 1)
                    rgb_neg_zoom_matched = np.zeros((*shape, 3), dtype=np.uint8)
                    if channel == 'green':
                        rgb_neg_zoom_matched[:, :, 1] = (neg_norm_matched * 255).astype(np.uint8)
                    else:  # orange
                        rgb_neg_zoom_matched[:, :, 0] = (neg_norm_matched * 255).astype(np.uint8)
                        rgb_neg_zoom_matched[:, :, 1] = (neg_norm_matched * 165).astype(np.uint8)

                    # Save clean TIFF (no circles)
                    imwrite(str(zoom_dir / f"negative_{channel_name}_zoom_matched_range.tif"), rgb_neg_zoom_matched)

                    # Save SVG with vector circles (white=passed, red=failed)
                    save_zoom_svg_with_threshold_circles(
                        rgb_neg_zoom_matched, neg_passed_in_zoom, neg_failed_in_zoom,
                        zoom_dir / f"negative_{channel_name}_zoom_with_spots_matched_range.svg",
                        circle_radius=3, dynamic_range=ch_range, channel_name=channel_name
                    )

                    # Create negative zoom with spots (auto range)
                    neg_norm_auto = normalize_image(neg_region)
                    neg_auto_range = compute_dynamic_range(neg_region)
                    rgb_neg_zoom_auto = np.zeros((*shape, 3), dtype=np.uint8)
                    if channel == 'green':
                        rgb_neg_zoom_auto[:, :, 1] = (neg_norm_auto * 255).astype(np.uint8)
                    else:  # orange
                        rgb_neg_zoom_auto[:, :, 0] = (neg_norm_auto * 255).astype(np.uint8)
                        rgb_neg_zoom_auto[:, :, 1] = (neg_norm_auto * 165).astype(np.uint8)

                    # Save clean TIFF (no circles)
                    imwrite(str(zoom_dir / f"negative_{channel_name}_zoom_auto_range.tif"), rgb_neg_zoom_auto)

                    # Save SVG with vector circles (white=passed, red=failed)
                    save_zoom_svg_with_threshold_circles(
                        rgb_neg_zoom_auto, neg_passed_in_zoom, neg_failed_in_zoom,
                        zoom_dir / f"negative_{channel_name}_zoom_with_spots_auto_range.svg",
                        circle_radius=3, dynamic_range=neg_auto_range, channel_name=channel_name
                    )

                # Save merged zoom images
                # Experimental merged zoom
                exp_zoom_blue, _ = extract_zoom_region(exp_projections['blue'], cx, cy, zoom_size)
                exp_zoom_green, _ = extract_zoom_region(exp_projections['green'], cx, cy, zoom_size)
                exp_zoom_orange, _ = extract_zoom_region(exp_projections['orange'], cx, cy, zoom_size)

                exp_zoom_merged = create_merged_rgb(exp_zoom_blue, exp_zoom_green, exp_zoom_orange)
                # Save TIFF without scale bar
                imwrite(str(zoom_dir / "experimental_merged_zoom.tif"), exp_zoom_merged)

                # Negative merged zoom with matched range
                neg_zoom_blue, _ = extract_zoom_region(projections['blue'], cx, cy, zoom_size)
                neg_zoom_green, _ = extract_zoom_region(projections['green'], cx, cy, zoom_size)
                neg_zoom_orange, _ = extract_zoom_region(projections['orange'], cx, cy, zoom_size)

                neg_zoom_merged = create_merged_rgb(
                    neg_zoom_blue, neg_zoom_green, neg_zoom_orange,
                    blue_range=blue_range, green_range=green_range, orange_range=orange_range
                )
                # Save TIFF without scale bar
                imwrite(str(zoom_dir / "negative_merged_zoom_matched_range.tif"), neg_zoom_merged)

                # Negative merged zoom with auto range
                neg_zoom_merged_auto = create_merged_rgb(neg_zoom_blue, neg_zoom_green, neg_zoom_orange)
                # Save TIFF without scale bar
                imwrite(str(zoom_dir / "negative_merged_zoom_auto_range.tif"), neg_zoom_merged_auto)

                # Compute auto ranges for negative control zoom regions
                neg_green_auto_range = compute_dynamic_range(neg_zoom_green)
                neg_orange_auto_range = compute_dynamic_range(neg_zoom_orange)
                neg_blue_auto_range = compute_dynamic_range(neg_zoom_blue)

                # Save zoom metadata
                with open(zoom_dir / "zoom_metadata.txt", 'w') as f:
                    f.write(f"ZOOM COMPARISON METADATA - {zoom_name.upper()}\n")
                    f.write(f"{'='*60}\n\n")
                    f.write(f"Zoom region:\n")
                    f.write(f"  Location: {zoom_name}\n")
                    f.write(f"  Center (x, y): ({cx}, {cy})\n")
                    f.write(f"  Size: {zoom_size} x {zoom_size} pixels\n")
                    f.write(f"  Size (µm): {zoom_size * PIXEL_SIZE_XY:.1f} x {zoom_size * PIXEL_SIZE_XY:.1f} µm\n")
                    f.write(f"  Scale bar: {SCALE_BAR_ZOOM} µm ({int(SCALE_BAR_ZOOM / PIXEL_SIZE_XY)} pixels)\n")
                    f.write(f"\n")
                    f.write(f"EXPERIMENTAL (slide: {exp_row['slide_std']})\n")
                    f.write(f"{'─'*60}\n")
                    f.write(f"  FOV Key: {exp_row['fov_key']}\n")
                    f.write(f"  Dynamic ranges (min, max intensity):\n")
                    f.write(f"    DAPI (blue):        {blue_range[0]:.1f} - {blue_range[1]:.1f}\n")
                    f.write(f"    mHTT1a (green):     {green_range[0]:.1f} - {green_range[1]:.1f}\n")
                    f.write(f"    full-length (orange): {orange_range[0]:.1f} - {orange_range[1]:.1f}\n")
                    f.write(f"\n")
                    f.write(f"NEGATIVE CONTROL (slide: {row['slide_std']})\n")
                    f.write(f"{'─'*60}\n")
                    f.write(f"  FOV Key: {row['fov_key']}\n")
                    f.write(f"  Auto-range (negative control zoom region):\n")
                    f.write(f"    DAPI (blue):        {neg_blue_auto_range[0]:.1f} - {neg_blue_auto_range[1]:.1f}\n")
                    f.write(f"    mHTT1a (green):     {neg_green_auto_range[0]:.1f} - {neg_green_auto_range[1]:.1f}\n")
                    f.write(f"    full-length (orange): {neg_orange_auto_range[0]:.1f} - {neg_orange_auto_range[1]:.1f}\n")
                    f.write(f"\n")
                    f.write(f"IMAGE FILES\n")
                    f.write(f"{'─'*60}\n")
                    f.write(f"  Experimental (no spots):\n")
                    f.write(f"    experimental_mHTT1a_zoom.tif:           green channel, auto-range\n")
                    f.write(f"    experimental_full_length_zoom.tif:      orange channel, auto-range\n")
                    f.write(f"    experimental_merged_zoom.tif:           RGB merged, auto-range\n")
                    f.write(f"\n")
                    f.write(f"  Experimental (with spots, white=passed, red=failed):\n")
                    f.write(f"    experimental_mHTT1a_zoom_with_spots.tif:      green + spots\n")
                    f.write(f"    experimental_full_length_zoom_with_spots.tif: orange + spots\n")
                    f.write(f"\n")
                    f.write(f"  Negative control - MATCHED RANGE (no spots):\n")
                    f.write(f"    negative_mHTT1a_zoom_matched_range.tif:      green, exp dynamic range\n")
                    f.write(f"    negative_full_length_zoom_matched_range.tif: orange, exp dynamic range\n")
                    f.write(f"    negative_merged_zoom_matched_range.tif:      RGB, exp dynamic range\n")
                    f.write(f"\n")
                    f.write(f"  Negative control - MATCHED RANGE (with spots, white=passed, red=failed):\n")
                    f.write(f"    negative_mHTT1a_zoom_with_spots_matched_range.tif:      green + spots\n")
                    f.write(f"    negative_full_length_zoom_with_spots_matched_range.tif: orange + spots\n")
                    f.write(f"\n")
                    f.write(f"  Negative control - AUTO RANGE (no spots):\n")
                    f.write(f"    negative_mHTT1a_zoom_auto_range.tif:         green, auto-range\n")
                    f.write(f"    negative_full_length_zoom_auto_range.tif:    orange, auto-range\n")
                    f.write(f"    negative_merged_zoom_auto_range.tif:         RGB, auto-range\n")
                    f.write(f"\n")
                    f.write(f"  Negative control - AUTO RANGE (with spots, white=passed, red=failed):\n")
                    f.write(f"    negative_mHTT1a_zoom_with_spots_auto_range.tif:      green + spots\n")
                    f.write(f"    negative_full_length_zoom_with_spots_auto_range.tif: orange + spots\n")
                    f.write(f"\n")
                    f.write(f"NOTE: 'matched_range' images use experimental dynamic range\n")
                    f.write(f"      for direct visual comparison. Negative control should\n")
                    f.write(f"      appear darker since signal is lower/absent.\n")

            print(f"    Saved: zoom comparison images at 5 locations ({zoom_size}x{zoom_size})")

            # ─────────────────────────────────────────────────────────────────────
            # Create SVGs showing overview with zoom box locations
            # ─────────────────────────────────────────────────────────────────────

            # Create experimental overview
            exp_overview_rgb = create_merged_rgb(exp_projections['blue'], exp_projections['green'],
                                                  exp_projections['orange'])

            # Save TIFF without zoom boxes (clean image)
            imwrite(str(fov_dir / "experimental_overview.tif"), exp_overview_rgb)

            # Save SVG with zoom boxes as vector elements (adjustable)
            zoom_boxes_with_size = [(cx, cy, zoom_size) for _, cx, cy in zoom_locations]
            save_composite_svg(exp_overview_rgb, fov_dir / "experimental_overview_with_zoom_boxes.svg",
                               green_range=green_range, orange_range=orange_range,
                               zoom_boxes=zoom_boxes_with_size, zoom_box_linewidth=3)

            # Create negative control overview (matched range - uses EXPERIMENTAL range)
            neg_overview_rgb = create_merged_rgb(projections['blue'], projections['green'],
                                                  projections['orange'],
                                                  blue_range=blue_range, green_range=green_range,
                                                  orange_range=orange_range)

            # Save TIFF without zoom boxes (clean image)
            imwrite(str(fov_dir / "negative_overview_matched_range.tif"), neg_overview_rgb)

            # Save SVG with zoom boxes as vector elements (adjustable)
            save_composite_svg(neg_overview_rgb, fov_dir / "negative_overview_with_zoom_boxes_matched_range.svg",
                               green_range=green_range, orange_range=orange_range,
                               zoom_boxes=zoom_boxes_with_size, zoom_box_linewidth=3)

            print(f"    Saved: overview images with zoom boxes (SVG + TIF)")

            # Compute negative control auto-ranges (already computed above, but needed for exp_info)
            neg_blue_range = compute_dynamic_range(projections['blue'])
            neg_green_range = compute_dynamic_range(projections['green'])
            neg_orange_range = compute_dynamic_range(projections['orange'])

            exp_info = {
                'slide': exp_row['slide_std'],
                'fov_key': exp_row['fov_key'],
                'npz': exp_npz_path,
                'blue_range': blue_range,
                'green_range': green_range,
                'orange_range': orange_range,
                'zoom_center': (cx, cy),
                'zoom_size': zoom_size,
                'neg_blue_range': neg_blue_range,
                'neg_green_range': neg_green_range,
                'neg_orange_range': neg_orange_range,
            }
        else:
            print(f"    WARNING: No experimental comparison found for {neg_slide}")
            # Compute negative control auto-ranges
            neg_blue_range = compute_dynamic_range(projections['blue'])
            neg_green_range = compute_dynamic_range(projections['green'])
            neg_orange_range = compute_dynamic_range(projections['orange'])

            # Just save negative control with auto range as TIFF (no scale bar)
            save_colored_tiff(projections['blue'], fov_dir / "negative_DAPI_auto_range.tif", 'blue')
            save_colored_tiff(projections['green'], fov_dir / "negative_mHTT1a_auto_range.tif", 'green')
            save_colored_tiff(projections['orange'], fov_dir / "negative_full_length_auto_range.tif", 'orange')
            save_rgb_tiff(projections['blue'], projections['green'], projections['orange'],
                          fov_dir / "negative_merged_auto_range.tif")
            exp_info = None

        # Save metadata
        with open(fov_dir / "metadata.txt", 'w') as f:
            f.write(f"{'='*60}\n")
            f.write(f"PANEL B - NEGATIVE CONTROL FOV {saved + 1}\n")
            f.write(f"{'='*60}\n\n")
            f.write(f"FOV Key: {row['fov_key']}\n")
            f.write(f"Slide: {row['slide_std']}\n")
            f.write(f"Mouse ID: {row.get('mouse_id', 'N/A')}\n")
            f.write(f"Genotype: {row.get('mouse_model', 'N/A')}\n")
            f.write(f"Age: {row.get('age', 'N/A')} months\n")
            f.write(f"Region: {row.get('brain_region', 'N/A')}\n")
            f.write(f"Probe Set: {row.get('probe_set', 'N/A')}\n")
            f.write(f"NPZ path: {npz_path}\n")
            f.write(f"\n")
            f.write(f"CELL AND SPOT COUNTS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Nuclei: {row.get('num_cells', 0):.0f}\n")
            f.write(f"  Total spots: {row.get('total_spots', 0):.0f}\n")
            f.write(f"  Green spots (mHTT1a): {row.get('green_spots', 0):.0f}\n")
            f.write(f"  Orange spots (full-length): {row.get('orange_spots', 0):.0f}\n")
            f.write(f"\n")
            f.write(f"SCALE BARS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Overview images: {SCALE_BAR_OVERVIEW} µm ({int(SCALE_BAR_OVERVIEW / PIXEL_SIZE_XY)} pixels)\n")
            f.write(f"  Zoom images:     {SCALE_BAR_ZOOM} µm ({int(SCALE_BAR_ZOOM / PIXEL_SIZE_XY)} pixels)\n")
            f.write(f"\n")

            if exp_info:
                f.write(f"EXPERIMENTAL COMPARISON\n")
                f.write(f"{'─'*60}\n")
                f.write(f"  Slide: {exp_info['slide']}\n")
                f.write(f"  FOV Key: {exp_info['fov_key']}\n")
                f.write(f"  NPZ path: {exp_info['npz']}\n")
                f.write(f"\n")
                f.write(f"IMAGE DYNAMIC RANGES\n")
                f.write(f"{'─'*60}\n")
                f.write(f"\n")
                f.write(f"  EXPERIMENTAL (auto-range, used for matched_range images):\n")
                f.write(f"    DAPI (blue):          {exp_info['blue_range'][0]:.1f} - {exp_info['blue_range'][1]:.1f}\n")
                f.write(f"    mHTT1a (green):       {exp_info['green_range'][0]:.1f} - {exp_info['green_range'][1]:.1f}\n")
                f.write(f"    full-length (orange): {exp_info['orange_range'][0]:.1f} - {exp_info['orange_range'][1]:.1f}\n")
                f.write(f"\n")
                f.write(f"  NEGATIVE CONTROL (auto-range):\n")
                f.write(f"    DAPI (blue):          {exp_info['neg_blue_range'][0]:.1f} - {exp_info['neg_blue_range'][1]:.1f}\n")
                f.write(f"    mHTT1a (green):       {exp_info['neg_green_range'][0]:.1f} - {exp_info['neg_green_range'][1]:.1f}\n")
                f.write(f"    full-length (orange): {exp_info['neg_orange_range'][0]:.1f} - {exp_info['neg_orange_range'][1]:.1f}\n")
                f.write(f"\n")
                f.write(f"IMAGE FILES\n")
                f.write(f"{'─'*60}\n")
                f.write(f"\n")
                f.write(f"  Experimental images (auto-range):\n")
                f.write(f"    experimental_DAPI.tif:        blue, {exp_info['blue_range'][0]:.1f} - {exp_info['blue_range'][1]:.1f}\n")
                f.write(f"    experimental_mHTT1a.tif:      green, {exp_info['green_range'][0]:.1f} - {exp_info['green_range'][1]:.1f}\n")
                f.write(f"    experimental_full_length.tif: orange, {exp_info['orange_range'][0]:.1f} - {exp_info['orange_range'][1]:.1f}\n")
                f.write(f"    experimental_merged.tif:      RGB merged\n")
                f.write(f"    experimental_mHTT1a_with_spots.tif:      green + spots (white=passed, red=failed)\n")
                f.write(f"    experimental_full_length_with_spots.tif: orange + spots (white=passed, red=failed)\n")
                f.write(f"\n")
                f.write(f"  Negative control - MATCHED RANGE (same as experimental):\n")
                f.write(f"    negative_DAPI_matched_range.tif:        blue, {exp_info['blue_range'][0]:.1f} - {exp_info['blue_range'][1]:.1f}\n")
                f.write(f"    negative_mHTT1a_matched_range.tif:      green, {exp_info['green_range'][0]:.1f} - {exp_info['green_range'][1]:.1f}\n")
                f.write(f"    negative_full_length_matched_range.tif: orange, {exp_info['orange_range'][0]:.1f} - {exp_info['orange_range'][1]:.1f}\n")
                f.write(f"    negative_merged_matched_range.tif:      RGB merged with exp ranges\n")
                f.write(f"\n")
                f.write(f"  Negative control - AUTO RANGE:\n")
                f.write(f"    negative_DAPI_auto_range.tif:        blue, {exp_info['neg_blue_range'][0]:.1f} - {exp_info['neg_blue_range'][1]:.1f}\n")
                f.write(f"    negative_mHTT1a_auto_range.tif:      green, {exp_info['neg_green_range'][0]:.1f} - {exp_info['neg_green_range'][1]:.1f}\n")
                f.write(f"    negative_full_length_auto_range.tif: orange, {exp_info['neg_orange_range'][0]:.1f} - {exp_info['neg_orange_range'][1]:.1f}\n")
                f.write(f"    negative_merged_auto_range.tif:      RGB merged with auto ranges\n")
                f.write(f"    negative_mHTT1a_with_spots.tif:      green + spots, auto-range (white=passed, red=failed)\n")
                f.write(f"    negative_full_length_with_spots.tif: orange + spots, auto-range (white=passed, red=failed)\n")
                f.write(f"    negative_mHTT1a_with_spots_matched_range.tif:      green + spots, exp range (white=passed, red=failed)\n")
                f.write(f"    negative_full_length_with_spots_matched_range.tif: orange + spots, exp range (white=passed, red=failed)\n")
                f.write(f"\n")
                if 'zoom_center' in exp_info:
                    f.write(f"ZOOM COMPARISON\n")
                    f.write(f"{'─'*60}\n")
                    f.write(f"  Center (x, y): {exp_info['zoom_center']}\n")
                    f.write(f"  Size: {exp_info['zoom_size']} x {exp_info['zoom_size']} pixels\n")
                    f.write(f"  Size (µm): {exp_info['zoom_size'] * PIXEL_SIZE_XY:.1f} x {exp_info['zoom_size'] * PIXEL_SIZE_XY:.1f} µm\n")
                    f.write(f"  Location: zoom_comparison/ subdirectory\n")
                    f.write(f"  See zoom_comparison/zoom_metadata.txt for detailed zoom ranges\n")
                f.write(f"\n")
                f.write(f"NOTE: 'matched_range' images use EXPERIMENTAL dynamic range\n")
                f.write(f"      for direct visual comparison. Negative control should\n")
                f.write(f"      appear darker since true signal is absent.\n")
            else:
                f.write(f"NEGATIVE CONTROL DYNAMIC RANGES (auto-range)\n")
                f.write(f"{'─'*60}\n")
                f.write(f"  DAPI (blue):          {neg_blue_range[0]:.1f} - {neg_blue_range[1]:.1f}\n")
                f.write(f"  mHTT1a (green):       {neg_green_range[0]:.1f} - {neg_green_range[1]:.1f}\n")
                f.write(f"  full-length (orange): {neg_orange_range[0]:.1f} - {neg_orange_range[1]:.1f}\n")

        print(f"  Saved: {fov_dir.name}/")
        saved += 1

    print(f"\n  Total saved: {saved} negative control FOVs in {panel_dir}")


# ══════════════════════════════════════════════════════════════════════════════
# SHARED FOV SELECTION FOR PANELS D AND G
# ══════════════════════════════════════════════════════════════════════════════

def find_negative_control_for_slide(df: pd.DataFrame, slide: str):
    """
    Find a negative control FOV from the same slide.

    Args:
        df: Full FOV metadata DataFrame
        slide: The slide name (e.g., 'm1a4')

    Returns:
        (row, npz_path) tuple or (None, None) if not found
    """
    # Get the slide prefix (e.g., 'm1a' from 'm1a4' or 'm1b' from 'm1b3')
    # Negative controls are on different slides but same imaging session
    # Try to find by matching the first 3 characters
    slide_prefix = slide[:3]  # e.g., 'm1a', 'm1b', 'm2a', etc.

    # Filter for negative controls
    df_neg = filter_fovs(df, probe_type='negative_control', min_nuclei=50)

    if len(df_neg) == 0:
        return None, None

    # Try to find one from the same slide prefix
    df_same_prefix = df_neg[df_neg['slide_std'].str.startswith(slide_prefix)]

    # If not found, just use any negative control
    if len(df_same_prefix) == 0:
        df_same_prefix = df_neg

    # Sort by lowest spots (best negative control)
    df_same_prefix = df_same_prefix.sort_values('total_spots', ascending=True)

    for _, row in df_same_prefix.iterrows():
        original_fov = row.get('original_fov_num', None)
        npz_path = find_npz_path(row['slide_raw'], row['region_num'], row['fov_num'], original_fov)
        if npz_path:
            return row, npz_path

    return None, None


def find_experimental_for_negative_control(df: pd.DataFrame, neg_slide: str, used_fov_keys: set = None):
    """
    Find an experimental FOV from the SAME SLIDE as a negative control.

    Args:
        df: Full FOV metadata DataFrame
        neg_slide: The negative control slide name (e.g., 'm1b1')
        used_fov_keys: Set of FOV keys already used (to avoid duplicates)

    Returns:
        (row, npz_path) tuple or (None, None) if not found
    """
    if used_fov_keys is None:
        used_fov_keys = set()

    # Filter for experimental Q111 FOVs
    df_exp = filter_fovs(df, genotype='Q111', probe_type='experimental', min_nuclei=50)

    if len(df_exp) == 0:
        return None, None

    # Exclude already used FOVs
    df_exp = df_exp[~df_exp['fov_key'].isin(used_fov_keys)]

    if len(df_exp) == 0:
        return None, None

    # Find experimental FOVs from the SAME SLIDE (exact match)
    df_same_slide = df_exp[df_exp['slide_std'] == neg_slide]

    # Fall back to same slide prefix if no exact match
    if len(df_same_slide) == 0:
        slide_prefix = neg_slide[:3]
        df_same_slide = df_exp[df_exp['slide_std'].str.startswith(slide_prefix)]

    # Fall back to same imaging session
    if len(df_same_slide) == 0:
        session_prefix = neg_slide[:2]  # 'm1', 'm2', 'm3'
        df_same_slide = df_exp[df_exp['slide_std'].str.startswith(session_prefix)]

    if len(df_same_slide) == 0:
        return None, None

    # Sort by spot count to get a representative FOV (near median)
    df_same_slide = df_same_slide.copy()
    median_spots = df_same_slide['total_spots'].median()
    df_same_slide['dist_to_median'] = np.abs(df_same_slide['total_spots'] - median_spots)
    df_same_slide = df_same_slide.sort_values('dist_to_median')

    for _, row in df_same_slide.iterrows():
        original_fov = row.get('original_fov_num', None)
        npz_path = find_npz_path(row['slide_raw'], row['region_num'], row['fov_num'], original_fov)
        if npz_path:
            return row, npz_path

    return None, None


def compute_dynamic_range(img, percentile_low=1, percentile_high=99.5):
    """Compute the dynamic range (vmin, vmax) from an image."""
    vmin, vmax = np.percentile(img, [percentile_low, percentile_high])
    return (vmin, vmax)


def select_average_fovs(df: pd.DataFrame, n_fovs: int = 3):
    """
    Select FOVs with average behavior (near median spot counts) from different slides.

    Returns list of (row, npz_path) tuples and the thresholds dict.
    """
    # Load photon thresholds from figure1.py
    thresholds = load_photon_thresholds()
    if not thresholds:
        print("  ERROR: No thresholds found. Run figure1.py first!")
        return [], thresholds
    print(f"  Loaded {len(thresholds)} photon thresholds")

    # Find slides that have thresholds
    slides_with_thresholds = set()
    for key in thresholds.keys():
        for slide_candidate in ['m1a1', 'm1a2', 'm1a4', 'm1a5', 'm1b1', 'm1b2', 'm1b3', 'm1b4', 'm1b5',
                                 'm2a2', 'm2a3', 'm2a4', 'm2a6', 'm2a7', 'm2a8', 'm2b1', 'm2b2', 'm2b4',
                                 'm2b5', 'm2b6', 'm2b7', 'm3a1', 'm3a2', 'm3a3', 'm3a4', 'm3a5', 'm3b2',
                                 'm3b3', 'm3b4', 'm3b5']:
            if slide_candidate in key:
                slides_with_thresholds.add(slide_candidate)
                break

    df_exp = filter_fovs(df, genotype='Q111', probe_type='experimental', min_nuclei=100)
    df_exp = df_exp[df_exp['slide_std'].isin(slides_with_thresholds)]

    # Filter for FOVs with spots in both channels
    df_exp = df_exp[
        (df_exp['green_spots'] > 50) &
        (df_exp['orange_spots'] > 50)
    ]

    if len(df_exp) == 0:
        print("  ERROR: No suitable experimental FOVs found!")
        return [], thresholds

    # Select FOVs near the MEDIAN spot count (average behavior)
    median_spots = df_exp['total_spots'].median()
    df_exp['dist_to_median'] = np.abs(df_exp['total_spots'] - median_spots)
    df_exp = df_exp.sort_values('dist_to_median')

    print(f"  Median total spots: {median_spots:.0f}")
    print(f"  Selecting FOVs near median for average behavior")

    # Select FOVs from different slides for variety
    selected_fovs = []
    used_slides = set()

    for _, row in df_exp.iterrows():
        slide = row['slide_std']
        if slide in used_slides:
            continue

        original_fov = row.get('original_fov_num', None)
        path = find_npz_path(row['slide_raw'], row['region_num'], row['fov_num'], original_fov)
        if path:
            selected_fovs.append((row, path))
            used_slides.add(slide)

            if len(selected_fovs) >= n_fovs:
                break

    return selected_fovs, thresholds


# ══════════════════════════════════════════════════════════════════════════════
# PANEL D: Spot Detection Overview + Sigma Variation Zooms
# ══════════════════════════════════════════════════════════════════════════════

def generate_panel_D(df: pd.DataFrame, n_fovs: int = 3):
    """
    Generate Panel D showing:
    1. FOV overview with FILTERED spots for each channel (green and orange)
    2. Zoom insets with spots colored by sigma_x (with colorbar)

    Generates images from multiple FOVs across different slides.
    Selects FOVs with average behavior (near median spot counts).

    Output structure:
        panel_D/
            fov_1/
                overview_DAPI.tif
                overview_green.tif, overview_green_with_spots.tif
                overview_orange.tif, overview_orange_with_spots.tif
                overview_merged.tif, overview_merged_with_spots.tif
                green_spot_coordinates.csv, orange_spot_coordinates.csv
                zoom_green_with_spots.png (with sigma_x colorbar)
                zoom_orange_with_spots.png (with sigma_x colorbar)
                metadata.txt
            fov_2/
                ...

    Returns:
        dict: FOV info including zoom centers for use by Panel G
              {fov_key: {'npz_path': path, 'row': row, 'green_center': (cx, cy), 'orange_center': (cx, cy)}}
    """
    print("\n" + "="*80)
    print("PANEL D: Spot Detection with Filtered Spots (Green & Orange)")
    print("="*80)

    # Create panel directory
    panel_dir = OUTPUT_DIR / 'panel_D'
    panel_dir.mkdir(parents=True, exist_ok=True)

    # Select FOVs with average behavior
    selected_fovs, thresholds = select_average_fovs(df, n_fovs)

    if not selected_fovs:
        print("  ERROR: No FOVs with NPZ files found!")
        return {}

    print(f"  Selected {len(selected_fovs)} FOVs from different slides")

    # Store FOV info for Panel G
    fov_info = {}

    # Process each FOV
    for fov_idx, (selected_row, npz_path) in enumerate(selected_fovs):
        fov_num = fov_idx + 1
        fov_key = selected_row['fov_key']
        slide = selected_row['slide_std']

        print(f"\n{'─'*80}")
        print(f"  FOV {fov_num}: {slide}")
        print(f"{'─'*80}")
        print_fov_metadata(selected_row, f"FOV {fov_num}")

        # Get thresholds for this slide
        green_thresh = get_threshold_for_slide_channel(thresholds, slide, 'green')
        orange_thresh = get_threshold_for_slide_channel(thresholds, slide, 'orange')
        print(f"\n  Thresholds for {slide}:")
        print(f"    Green: {green_thresh:.0f} photons" if green_thresh else "    Green: N/A")
        print(f"    Orange: {orange_thresh:.0f} photons" if orange_thresh else "    Orange: N/A")

        # Get filtered spots for this specific FOV
        spots_green = load_filtered_spots_for_fov(fov_key, slide, 'green', thresholds=thresholds)
        spots_orange = load_filtered_spots_for_fov(fov_key, slide, 'orange', thresholds=thresholds)

        print(f"\n  Filtered spots for this FOV:")
        print(f"    Green: {len(spots_green):,} spots")
        print(f"    Orange: {len(spots_orange):,} spots")

        # Create FOV directory
        fov_dir = panel_dir / f'fov_{fov_num}'
        fov_dir.mkdir(parents=True, exist_ok=True)

        # Load image data
        projections, stacks = load_and_project_npz(npz_path)

        # Save overview images (color-coded, without spots, with scale bar)
        # Save overview images as TIFF (no scale bar)
        save_colored_tiff(projections['green'], fov_dir / "overview_green.tif", 'green')
        save_colored_tiff(projections['orange'], fov_dir / "overview_orange.tif", 'orange')
        save_colored_tiff(projections['blue'], fov_dir / "overview_DAPI.tif", 'blue')
        save_rgb_tiff(projections['blue'], projections['green'], projections['orange'],
                      fov_dir / "overview_merged.tif")

        # Compute dynamic ranges for annotations
        green_range = compute_dynamic_range(projections['green'])
        orange_range = compute_dynamic_range(projections['orange'])

        # Save GREEN channel - clean TIFF + SVG with vector circles
        if len(spots_green) > 0:
            # Create color-coded RGB image (no circles baked in)
            green_rgb = np.zeros((*projections['green'].shape, 3), dtype=np.uint8)
            green_rgb[:, :, 1] = (normalize_image(projections['green']) * 255).astype(np.uint8)

            # Save SVG with vector circles (clean, adjustable)
            save_image_svg_with_vector_circles(
                green_rgb, spots_green,
                fov_dir / "overview_green_with_spots.svg",
                circle_radius=4, circle_color='yellow', linewidth=1.0,
                dynamic_range=green_range, channel_name='Green'
            )
            spots_green.to_csv(fov_dir / "green_spot_coordinates.csv", index=False)
            print(f"  Saved: green SVG with {len(spots_green)} vector circles")

        # Save ORANGE channel - clean TIFF + SVG with vector circles
        if len(spots_orange) > 0:
            # Create color-coded RGB image (no circles baked in)
            orange_rgb = np.zeros((*projections['orange'].shape, 3), dtype=np.uint8)
            orange_norm = normalize_image(projections['orange'])
            orange_rgb[:, :, 0] = (orange_norm * 255).astype(np.uint8)
            orange_rgb[:, :, 1] = (orange_norm * 165).astype(np.uint8)

            # Save SVG with vector circles (clean, adjustable)
            save_image_svg_with_vector_circles(
                orange_rgb, spots_orange,
                fov_dir / "overview_orange_with_spots.svg",
                circle_radius=4, circle_color='cyan', linewidth=1.0,
                dynamic_range=orange_range, channel_name='Orange'
            )
            spots_orange.to_csv(fov_dir / "orange_spot_coordinates.csv", index=False)
            print(f"  Saved: orange SVG with {len(spots_orange)} vector circles")

        # Save merged RGB - clean TIFF + SVG with vector circles for both channels
        rgb_merged = create_merged_rgb(projections['blue'], projections['green'], projections['orange'])

        # Save clean merged TIFF (no circles)
        imwrite(str(fov_dir / "overview_merged.tif"), rgb_merged)

        # Save merged SVG with vector circles for both channels
        save_merged_svg_with_vector_circles(
            rgb_merged, spots_green, spots_orange,
            fov_dir / "overview_merged_with_spots.svg",
            circle_radius=4, linewidth=1.0,
            green_range=green_range, orange_range=orange_range
        )
        print(f"  Saved: merged SVG with vector circles")

        # ─────────────────────────────────────────────────────────────────────
        # Generate zoom insets centered on spot clusters with sigma_x colorbar
        # spots_green and spots_orange already have sigma values from spots_sigma_var
        # ─────────────────────────────────────────────────────────────────────
        zoom_size = 256  # pixels for zoom inset

        # Initialize FOV info entry
        fov_info[fov_key] = {
            'npz_path': npz_path,
            'row': selected_row,
            'fov_num': fov_num,
            'green_center': None,
            'orange_center': None,
            'zoom_size': zoom_size
        }

        # Compute dynamic ranges for overview images
        blue_range = compute_dynamic_range(projections['blue'])
        green_range = compute_dynamic_range(projections['green'])
        orange_range = compute_dynamic_range(projections['orange'])

        # Store for metadata
        zoom_metadata = {
            'green': {'center': None, 'n_spots': 0, 'range': None, 'sigma_range': None},
            'orange': {'center': None, 'n_spots': 0, 'range': None, 'sigma_range': None}
        }

        # GREEN channel zoom with sigma_x colorbar
        # spots_green already has sigma_x from spots_sigma_var
        if len(spots_green) >= 5:
            center = find_spot_cluster_center(spots_green, min_spots=5)
            if center:
                cx, cy = center
                fov_info[fov_key]['green_center'] = (cx, cy)
                n_in_zoom = save_zoom_with_spots(
                    projections['green'], spots_green, cx, cy, zoom_size,
                    fov_dir / "zoom_green_with_spots.svg",
                    circle_radius=7, circle_color=(255, 255, 0),
                    spots_sigma_df=spots_green,  # Use spots_green directly (has sigma)
                    colorbar_label='sigma_x (pixels)',
                    channel='green'
                )
                print(f"  Saved: green zoom SVG with {n_in_zoom} spots (sigma_x colorbar, scale bar, dynamic range)")

                # Also save without circles for reference as TIFF (no scale bar)
                region, (x_min, x_max, y_min, y_max) = extract_zoom_region(projections['green'], cx, cy, zoom_size)
                save_colored_tiff(region, fov_dir / "zoom_green.tif", 'green')

                # Get sigma range for spots in zoom
                mask = (spots_green['pos_x'] >= x_min) & (spots_green['pos_x'] < x_max) & \
                       (spots_green['pos_y'] >= y_min) & (spots_green['pos_y'] < y_max)
                spots_in_zoom = spots_green[mask]
                sigma_range = (spots_in_zoom['sigma_x'].min(), spots_in_zoom['sigma_x'].max()) if len(spots_in_zoom) > 0 else (None, None)

                zoom_metadata['green'] = {
                    'center': (cx, cy),
                    'n_spots': n_in_zoom,
                    'range': compute_dynamic_range(region),
                    'sigma_range': sigma_range
                }

        # ORANGE channel zoom with sigma_x colorbar
        # spots_orange already has sigma_x from spots_sigma_var
        if len(spots_orange) >= 5:
            center = find_spot_cluster_center(spots_orange, min_spots=5)
            if center:
                cx, cy = center
                fov_info[fov_key]['orange_center'] = (cx, cy)
                n_in_zoom = save_zoom_with_spots(
                    projections['orange'], spots_orange, cx, cy, zoom_size,
                    fov_dir / "zoom_orange_with_spots.svg",
                    circle_radius=7, circle_color=(0, 255, 255),
                    spots_sigma_df=spots_orange,  # Use spots_orange directly (has sigma)
                    colorbar_label='sigma_x (pixels)',
                    channel='orange'
                )
                print(f"  Saved: orange zoom SVG with {n_in_zoom} spots (sigma_x colorbar, scale bar, dynamic range)")

                # Also save without circles for reference as TIFF (no scale bar)
                region, (x_min, x_max, y_min, y_max) = extract_zoom_region(projections['orange'], cx, cy, zoom_size)
                save_colored_tiff(region, fov_dir / "zoom_orange.tif", 'orange')

                # Get sigma range for spots in zoom
                mask = (spots_orange['pos_x'] >= x_min) & (spots_orange['pos_x'] < x_max) & \
                       (spots_orange['pos_y'] >= y_min) & (spots_orange['pos_y'] < y_max)
                spots_in_zoom = spots_orange[mask]
                sigma_range = (spots_in_zoom['sigma_x'].min(), spots_in_zoom['sigma_x'].max()) if len(spots_in_zoom) > 0 else (None, None)

                zoom_metadata['orange'] = {
                    'center': (cx, cy),
                    'n_spots': n_in_zoom,
                    'range': compute_dynamic_range(region),
                    'sigma_range': sigma_range
                }

        # Save metadata
        PIXEL_SIZE_NM = PIXEL_SIZE_XY * 1000  # 162.5 nm per pixel

        with open(fov_dir / "metadata.txt", 'w') as f:
            f.write(f"{'='*60}\n")
            f.write(f"PANEL D - FOV {fov_num} METADATA\n")
            f.write(f"{'='*60}\n\n")
            f.write(f"FOV Key: {fov_key}\n")
            f.write(f"Slide: {slide}\n")
            f.write(f"Mouse ID: {selected_row.get('mouse_id', 'N/A')}\n")
            f.write(f"Genotype: {selected_row.get('mouse_model', 'N/A')}\n")
            f.write(f"Age: {selected_row.get('age', 'N/A')} months\n")
            f.write(f"Region: {selected_row.get('brain_region', 'N/A')}\n")
            f.write(f"Probe Set: {selected_row.get('probe_set', 'N/A')}\n")
            f.write(f"NPZ path: {npz_path}\n")
            f.write(f"\n")
            f.write(f"OVERVIEW IMAGE DYNAMIC RANGES (min, max intensity)\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  DAPI (blue):          {blue_range[0]:.1f} - {blue_range[1]:.1f}\n")
            f.write(f"  mHTT1a (green):       {green_range[0]:.1f} - {green_range[1]:.1f}\n")
            f.write(f"  full-length (orange): {orange_range[0]:.1f} - {orange_range[1]:.1f}\n")
            f.write(f"\n")
            f.write(f"SPOT FILTERING (Panel D)\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  1. spots_sigma_var.filter_indices (variable sigma fitting passed)\n")
            f.write(f"  2. photons > slide/channel threshold (95th pct of negative control)\n")
            f.write(f"\n")
            f.write(f"PHOTON THRESHOLDS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Green: {green_thresh:.0f} photons\n" if green_thresh else "  Green: N/A\n")
            f.write(f"  Orange: {orange_thresh:.0f} photons\n" if orange_thresh else "  Orange: N/A\n")
            f.write(f"\n")
            f.write(f"FILTERED SPOT COUNTS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Green (mHTT1a):       {len(spots_green):,} spots\n")
            f.write(f"  Orange (full-length): {len(spots_orange):,} spots\n")
            f.write(f"\n")
            f.write(f"ZOOM REGIONS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Zoom size: {zoom_size} x {zoom_size} pixels ({zoom_size * PIXEL_SIZE_XY:.1f} x {zoom_size * PIXEL_SIZE_XY:.1f} µm)\n")
            f.write(f"\n")
            f.write(f"SCALE BARS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Overview images: {SCALE_BAR_OVERVIEW} µm ({int(SCALE_BAR_OVERVIEW / PIXEL_SIZE_XY)} pixels)\n")
            f.write(f"  Zoom images:     {SCALE_BAR_ZOOM} µm ({int(SCALE_BAR_ZOOM / PIXEL_SIZE_XY)} pixels)\n")
            f.write(f"\n")
            if zoom_metadata['green']['center']:
                g = zoom_metadata['green']
                f.write(f"  GREEN (mHTT1a) zoom:\n")
                f.write(f"    Center (x, y): {g['center']}\n")
                f.write(f"    Spots in zoom: {g['n_spots']}\n")
                f.write(f"    Intensity range: {g['range'][0]:.1f} - {g['range'][1]:.1f}\n")
                if g['sigma_range'][0] is not None:
                    f.write(f"    σₓ range (pixels): {g['sigma_range'][0]:.2f} - {g['sigma_range'][1]:.2f}\n")
                    f.write(f"    σₓ range (nm): {g['sigma_range'][0] * PIXEL_SIZE_NM:.1f} - {g['sigma_range'][1] * PIXEL_SIZE_NM:.1f}\n")
            f.write(f"\n")
            if zoom_metadata['orange']['center']:
                o = zoom_metadata['orange']
                f.write(f"  ORANGE (full-length) zoom:\n")
                f.write(f"    Center (x, y): {o['center']}\n")
                f.write(f"    Spots in zoom: {o['n_spots']}\n")
                f.write(f"    Intensity range: {o['range'][0]:.1f} - {o['range'][1]:.1f}\n")
                if o['sigma_range'][0] is not None:
                    f.write(f"    σₓ range (pixels): {o['sigma_range'][0]:.2f} - {o['sigma_range'][1]:.2f}\n")
                    f.write(f"    σₓ range (nm): {o['sigma_range'][0] * PIXEL_SIZE_NM:.1f} - {o['sigma_range'][1] * PIXEL_SIZE_NM:.1f}\n")
            f.write(f"\n")
            f.write(f"NOTE: Panel G uses SAME locations but STRICTER filtering\n")
            f.write(f"      (adds filter_on_break = breakpoint filter for single molecules)\n")

        print(f"  Saved: {fov_dir}/")

    print(f"\n  Total: {len(selected_fovs)} FOVs saved to {panel_dir}")

    return fov_info


# ══════════════════════════════════════════════════════════════════════════════
# PANEL G: Spots from Green (H) and Orange (I) channels
# ══════════════════════════════════════════════════════════════════════════════

def generate_panel_G(df: pd.DataFrame, fov_info: dict = None):
    """
    Generate Panel G showing example spots from both channels:
    - Green channel (mHTT1a) - corresponds to panel H
    - Orange channel (full-length mHTT) - corresponds to panel I

    Uses the SAME FOVs and zoom locations as Panel D for direct comparison.
    Panel G uses STRICTER filtering than Panel D:
    - spots_sigma_var.filter_indices (variable sigma fitting)
    - spots_sigma_var.filter_on_break (breakpoint filter for single molecules)
    - photon threshold

    This results in FEWER spots than Panel D but cleaner single-molecule detection.

    Args:
        df: FOV metadata DataFrame
        fov_info: Dict from Panel D with FOV info and zoom centers.
                  If None, will use same selection as Panel D.

    Output structure:
        panel_G/
            fov_1/
                overview_DAPI.tif
                overview_green.tif, overview_green_with_spots.tif
                overview_orange.tif, overview_orange_with_spots.tif
                overview_merged.tif, overview_merged_with_spots.tif
                green_spot_coordinates.csv, orange_spot_coordinates.csv
                zoom_green_with_spots.png (with sigma_x colorbar)
                zoom_orange_with_spots.png (with sigma_x colorbar)
                zoom_green.tif, zoom_orange.tif
                metadata.txt
    """
    print("\n" + "="*80)
    print("PANEL G: Spot Examples (STRICTER filter: sigma_var + breakpoint)")
    print("="*80)

    # Create panel directory
    panel_dir = OUTPUT_DIR / 'panel_G'
    panel_dir.mkdir(parents=True, exist_ok=True)

    # If no fov_info provided, select the same FOVs
    if fov_info is None:
        print("  WARNING: No fov_info from Panel D, selecting FOVs independently")
        selected_fovs, thresholds = select_average_fovs(df, n_fovs=3)
        # Build fov_info structure
        fov_info = {}
        for fov_idx, (row, npz_path) in enumerate(selected_fovs):
            fov_info[row['fov_key']] = {
                'npz_path': npz_path,
                'row': row,
                'fov_num': fov_idx + 1,
                'green_center': None,
                'orange_center': None,
                'zoom_size': 256
            }
    else:
        thresholds = load_photon_thresholds()

    if not fov_info:
        print("  ERROR: No FOVs to process!")
        return

    print(f"  Processing {len(fov_info)} FOVs (same as Panel D)")

    # Process each FOV from Panel D
    for fov_key, info in fov_info.items():
        fov_num = info['fov_num']
        npz_path = info['npz_path']
        selected_row = info['row']
        green_center = info['green_center']
        orange_center = info['orange_center']
        zoom_size = info['zoom_size']
        slide = selected_row['slide_std']

        print(f"\n{'─'*80}")
        print(f"  FOV {fov_num}: {slide}")
        print(f"{'─'*80}")
        print_fov_metadata(selected_row, f"FOV {fov_num}")

        # Create FOV directory
        fov_dir = panel_dir / f'fov_{fov_num}'
        fov_dir.mkdir(parents=True, exist_ok=True)

        # Load image data
        projections, stacks = load_and_project_npz(npz_path)

        # ─────────────────────────────────────────────────────────────────────
        # Panel G uses STRICTER filtering than Panel D:
        # - spots_sigma_var.filter_indices (variable sigma fitting)
        # - spots_sigma_var.filter_on_break (breakpoint filter)
        # - photon threshold
        # ─────────────────────────────────────────────────────────────────────
        spots_sigma_green = load_filtered_spots_with_sigma(fov_key, slide, 'green', thresholds=thresholds)
        spots_sigma_orange = load_filtered_spots_with_sigma(fov_key, slide, 'orange', thresholds=thresholds)

        print(f"\n  Filtered spots with sigma (STRICTER than Panel D):")
        print(f"    Green: {len(spots_sigma_green) if spots_sigma_green is not None else 0:,} spots")
        print(f"    Orange: {len(spots_sigma_orange) if spots_sigma_orange is not None else 0:,} spots")

        # Save overview images as TIFF (no scale bar)
        save_colored_tiff(projections['green'], fov_dir / "overview_green.tif", 'green')
        save_colored_tiff(projections['orange'], fov_dir / "overview_orange.tif", 'orange')
        save_colored_tiff(projections['blue'], fov_dir / "overview_DAPI.tif", 'blue')
        save_rgb_tiff(projections['blue'], projections['green'], projections['orange'],
                      fov_dir / "overview_merged.tif")

        # Compute dynamic ranges for overview images
        blue_range = compute_dynamic_range(projections['blue'])
        green_range = compute_dynamic_range(projections['green'])
        orange_range = compute_dynamic_range(projections['orange'])

        # Store for metadata
        zoom_metadata = {
            'green': {'center': green_center, 'n_spots': 0, 'range': None, 'sigma_range': None},
            'orange': {'center': orange_center, 'n_spots': 0, 'range': None, 'sigma_range': None}
        }

        # Save GREEN channel with sigma_var spot circles as SVG with vector circles
        if spots_sigma_green is not None and len(spots_sigma_green) > 0:
            # Create colored RGB for the green channel
            green_rgb = np.zeros((*projections['green'].shape, 3), dtype=np.uint8)
            green_rgb[:, :, 1] = (normalize_image(projections['green']) * 255).astype(np.uint8)

            # Save SVG with vector circles
            save_image_svg_with_vector_circles(
                green_rgb, spots_sigma_green,
                fov_dir / "overview_green_with_spots.svg",
                circle_radius=4, circle_color='yellow', linewidth=1.0,
                dynamic_range=green_range, channel_name='Green'
            )
            spots_sigma_green.to_csv(fov_dir / "green_spot_coordinates.csv", index=False)
            print(f"  Saved: green channel SVG with {len(spots_sigma_green)} sigma_var spots (vector circles)")

        # Save ORANGE channel with sigma_var spot circles as SVG with vector circles
        if spots_sigma_orange is not None and len(spots_sigma_orange) > 0:
            # Create colored RGB for the orange channel
            orange_rgb = np.zeros((*projections['orange'].shape, 3), dtype=np.uint8)
            norm_orange = normalize_image(projections['orange'])
            orange_rgb[:, :, 0] = (norm_orange * 255).astype(np.uint8)  # Red
            orange_rgb[:, :, 1] = (norm_orange * 0.5 * 255).astype(np.uint8)  # Half green for orange

            # Save SVG with vector circles
            save_image_svg_with_vector_circles(
                orange_rgb, spots_sigma_orange,
                fov_dir / "overview_orange_with_spots.svg",
                circle_radius=4, circle_color='cyan', linewidth=1.0,
                dynamic_range=orange_range, channel_name='Orange'
            )
            spots_sigma_orange.to_csv(fov_dir / "orange_spot_coordinates.csv", index=False)
            print(f"  Saved: orange channel SVG with {len(spots_sigma_orange)} sigma_var spots (vector circles)")

        # Save merged with both channels' spots as SVG with vector circles
        rgb_merged = create_merged_rgb(projections['blue'], projections['green'], projections['orange'])

        # Save clean TIFF without circles
        imwrite(str(fov_dir / "overview_merged.tif"), rgb_merged)

        # Save SVG with vector circles for both channels
        save_merged_svg_with_vector_circles(
            rgb_merged, spots_sigma_green, spots_sigma_orange,
            fov_dir / "overview_merged_with_spots.svg",
            circle_radius=4, linewidth=1.0,
            green_range=green_range, orange_range=orange_range
        )
        print(f"  Saved: merged SVG with both channels' sigma_var spots (vector circles)")

        # ─────────────────────────────────────────────────────────────────────
        # Generate zoom insets at SAME locations as Panel D
        # Uses sigma_var spots with sigma_x colorbar
        # ─────────────────────────────────────────────────────────────────────

        # GREEN channel zoom (same center as Panel D)
        if green_center is not None and spots_sigma_green is not None and len(spots_sigma_green) > 0:
            cx, cy = green_center
            n_in_zoom = save_zoom_with_spots(
                projections['green'], spots_sigma_green, cx, cy, zoom_size,
                fov_dir / "zoom_green_with_spots.svg",
                circle_radius=7, circle_color=(255, 255, 0),
                spots_sigma_df=spots_sigma_green,
                colorbar_label='sigma_x (pixels)',
                channel='green'
            )
            print(f"  Saved: green zoom SVG with {n_in_zoom} sigma_var spots (same location as Panel D)")

            # Also save without circles for reference as TIFF (no scale bar)
            region, (x_min, x_max, y_min, y_max) = extract_zoom_region(projections['green'], cx, cy, zoom_size)
            save_colored_tiff(region, fov_dir / "zoom_green.tif", 'green')

            # Get sigma range for spots in zoom
            mask = (spots_sigma_green['pos_x'] >= x_min) & (spots_sigma_green['pos_x'] < x_max) & \
                   (spots_sigma_green['pos_y'] >= y_min) & (spots_sigma_green['pos_y'] < y_max)
            spots_in_zoom = spots_sigma_green[mask]
            sigma_range = (spots_in_zoom['sigma_x'].min(), spots_in_zoom['sigma_x'].max()) if len(spots_in_zoom) > 0 else (None, None)

            zoom_metadata['green'] = {
                'center': (cx, cy),
                'n_spots': n_in_zoom,
                'range': compute_dynamic_range(region),
                'sigma_range': sigma_range
            }

        # ORANGE channel zoom (same center as Panel D)
        if orange_center is not None and spots_sigma_orange is not None and len(spots_sigma_orange) > 0:
            cx, cy = orange_center
            n_in_zoom = save_zoom_with_spots(
                projections['orange'], spots_sigma_orange, cx, cy, zoom_size,
                fov_dir / "zoom_orange_with_spots.svg",
                circle_radius=7, circle_color=(0, 255, 255),
                spots_sigma_df=spots_sigma_orange,
                colorbar_label='sigma_x (pixels)',
                channel='orange'
            )
            print(f"  Saved: orange zoom SVG with {n_in_zoom} sigma_var spots (same location as Panel D)")

            # Also save without circles for reference as TIFF (no scale bar)
            region, (x_min, x_max, y_min, y_max) = extract_zoom_region(projections['orange'], cx, cy, zoom_size)
            save_colored_tiff(region, fov_dir / "zoom_orange.tif", 'orange')

            # Get sigma range for spots in zoom
            mask = (spots_sigma_orange['pos_x'] >= x_min) & (spots_sigma_orange['pos_x'] < x_max) & \
                   (spots_sigma_orange['pos_y'] >= y_min) & (spots_sigma_orange['pos_y'] < y_max)
            spots_in_zoom = spots_sigma_orange[mask]
            sigma_range = (spots_in_zoom['sigma_x'].min(), spots_in_zoom['sigma_x'].max()) if len(spots_in_zoom) > 0 else (None, None)

            zoom_metadata['orange'] = {
                'center': (cx, cy),
                'n_spots': n_in_zoom,
                'range': compute_dynamic_range(region),
                'sigma_range': sigma_range
            }

        # Save FOV metadata
        PIXEL_SIZE_NM = PIXEL_SIZE_XY * 1000  # 162.5 nm per pixel

        # Get thresholds for this slide
        green_thresh = get_threshold_for_slide_channel(thresholds, slide, 'green')
        orange_thresh = get_threshold_for_slide_channel(thresholds, slide, 'orange')

        with open(fov_dir / "metadata.txt", 'w') as f:
            f.write(f"{'='*60}\n")
            f.write(f"PANEL G - FOV {fov_num} METADATA (STRICTER filter)\n")
            f.write(f"{'='*60}\n\n")
            f.write(f"FOV Key: {fov_key}\n")
            f.write(f"Slide: {slide}\n")
            f.write(f"Mouse ID: {selected_row.get('mouse_id', 'N/A')}\n")
            f.write(f"Genotype: {selected_row.get('mouse_model', 'N/A')}\n")
            f.write(f"Age: {selected_row.get('age', 'N/A')} months\n")
            f.write(f"Region: {selected_row.get('brain_region', 'N/A')}\n")
            f.write(f"Probe Set: {selected_row.get('probe_set', 'N/A')}\n")
            f.write(f"NPZ path: {npz_path}\n")
            f.write(f"\n")
            f.write(f"OVERVIEW IMAGE DYNAMIC RANGES (min, max intensity)\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  DAPI (blue):          {blue_range[0]:.1f} - {blue_range[1]:.1f}\n")
            f.write(f"  mHTT1a (green):       {green_range[0]:.1f} - {green_range[1]:.1f}\n")
            f.write(f"  full-length (orange): {orange_range[0]:.1f} - {orange_range[1]:.1f}\n")
            f.write(f"\n")
            f.write(f"SPOT FILTERING (Panel G - STRICTER than Panel D)\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  1. spots_sigma_var.filter_indices (variable sigma fitting passed)\n")
            f.write(f"  2. spots_sigma_var.filter_on_break (breakpoint filter)\n")
            f.write(f"  3. photons > slide/channel threshold (from negative control)\n")
            f.write(f"\n")
            f.write(f"PHOTON THRESHOLDS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Green: {green_thresh:.0f} photons\n" if green_thresh else "  Green: N/A\n")
            f.write(f"  Orange: {orange_thresh:.0f} photons\n" if orange_thresh else "  Orange: N/A\n")
            f.write(f"\n")
            f.write(f"FILTERED SPOT COUNTS (STRICTER than Panel D)\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Green (mHTT1a):       {len(spots_sigma_green) if spots_sigma_green is not None else 0:,} spots\n")
            f.write(f"  Orange (full-length): {len(spots_sigma_orange) if spots_sigma_orange is not None else 0:,} spots\n")
            f.write(f"\n")
            f.write(f"ZOOM REGIONS (same locations as Panel D)\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Zoom size: {zoom_size} x {zoom_size} pixels ({zoom_size * PIXEL_SIZE_XY:.1f} x {zoom_size * PIXEL_SIZE_XY:.1f} µm)\n")
            f.write(f"\n")
            f.write(f"SCALE BARS\n")
            f.write(f"{'─'*60}\n")
            f.write(f"  Overview images: {SCALE_BAR_OVERVIEW} µm ({int(SCALE_BAR_OVERVIEW / PIXEL_SIZE_XY)} pixels)\n")
            f.write(f"  Zoom images:     {SCALE_BAR_ZOOM} µm ({int(SCALE_BAR_ZOOM / PIXEL_SIZE_XY)} pixels)\n")
            f.write(f"\n")
            if zoom_metadata['green']['center']:
                g = zoom_metadata['green']
                f.write(f"  GREEN (mHTT1a) zoom:\n")
                f.write(f"    Center (x, y): {g['center']}\n")
                f.write(f"    Spots in zoom: {g['n_spots']}\n")
                if g['range']:
                    f.write(f"    Intensity range: {g['range'][0]:.1f} - {g['range'][1]:.1f}\n")
                if g['sigma_range'] and g['sigma_range'][0] is not None:
                    f.write(f"    σₓ range (pixels): {g['sigma_range'][0]:.2f} - {g['sigma_range'][1]:.2f}\n")
                    f.write(f"    σₓ range (nm): {g['sigma_range'][0] * PIXEL_SIZE_NM:.1f} - {g['sigma_range'][1] * PIXEL_SIZE_NM:.1f}\n")
            f.write(f"\n")
            if zoom_metadata['orange']['center']:
                o = zoom_metadata['orange']
                f.write(f"  ORANGE (full-length) zoom:\n")
                f.write(f"    Center (x, y): {o['center']}\n")
                f.write(f"    Spots in zoom: {o['n_spots']}\n")
                if o['range']:
                    f.write(f"    Intensity range: {o['range'][0]:.1f} - {o['range'][1]:.1f}\n")
                if o['sigma_range'] and o['sigma_range'][0] is not None:
                    f.write(f"    σₓ range (pixels): {o['sigma_range'][0]:.2f} - {o['sigma_range'][1]:.2f}\n")
                    f.write(f"    σₓ range (nm): {o['sigma_range'][0] * PIXEL_SIZE_NM:.1f} - {o['sigma_range'][1] * PIXEL_SIZE_NM:.1f}\n")
            f.write(f"\n")
            f.write(f"NOTE: Panel D uses filter_indices ONLY = MORE spots\n")
            f.write(f"      Panel G adds filter_on_break = FEWER, cleaner single-molecule spots\n")

        print(f"  Saved: {fov_dir}/")

    print(f"\n  Total: {len(fov_info)} FOVs saved to {panel_dir}")


# ══════════════════════════════════════════════════════════════════════════════
# MAIN
# ══════════════════════════════════════════════════════════════════════════════

def main():
    """Generate all Figure 1 panel images."""

    print("="*80)
    print("FIGURE 1 PANEL GENERATION")
    print("="*80)

    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    # Load FOV-level data (shared across panels)
    print("\nLoading FOV-level data...")
    df_fov, thresholds = load_fov_level_data()

    # ─────────────────────────────────────────────────────────────────────────────
    # PANELS B & D: Use BEAD H5 file (sigma calibration reference)
    # ─────────────────────────────────────────────────────────────────────────────
    print("\n" + "─"*80)
    print("Loading BEAD H5 data for Panels B & D...")
    h5_path_bead = find_h5_file('bead')
    if h5_path_bead is None:
        print("  ERROR: Bead H5 file not found!")
        return
    print(f"  Using: {h5_path_bead}")

    df_bead = load_fov_metadata(h5_path_bead)
    if df_fov is not None:
        df_bead = merge_h5_with_fov_data(df_bead, df_fov)
    print(f"  Total FOVs (bead): {len(df_bead)}")

    # Generate Panels B & D with bead data
    generate_panel_B(df_bead, n_images=8)
    fov_info = generate_panel_D(df_bead, n_fovs=5)

    # ─────────────────────────────────────────────────────────────────────────────
    # PANEL G: Use EXPERIMENTAL H5 file (experimental PSF data)
    # ─────────────────────────────────────────────────────────────────────────────
    print("\n" + "─"*80)
    print("Loading EXPERIMENTAL H5 data for Panel G...")
    h5_path_exp = find_h5_file('experimental')
    if h5_path_exp is None:
        print("  ERROR: Experimental H5 file not found!")
        return
    print(f"  Using: {h5_path_exp}")

    df_exp = load_fov_metadata(h5_path_exp)
    if df_fov is not None:
        df_exp = merge_h5_with_fov_data(df_exp, df_fov)
    print(f"  Total FOVs (experimental): {len(df_exp)}")

    # Generate Panel G with experimental data
    generate_panel_G(df_exp, fov_info=fov_info)

    print("\n" + "="*80)
    print("DONE! Output saved to:")
    print(f"  {OUTPUT_DIR}")
    print("="*80)

    # List generated files
    print("\nGenerated files:")
    for f in sorted(OUTPUT_DIR.glob("panel_*")):
        print(f"  {f.name}")


if __name__ == '__main__':
    main()
